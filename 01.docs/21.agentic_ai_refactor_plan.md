# 21. Agentic AI 기반 멀티 에이전트 재정리 계획 (Architecture + Directory Refactor Plan)

> 목적: 현재 개별적으로 개발된 에이전트(검색 RAG, PPT 생성, KIPRIS 선행기술 검색)를 **통합/확장 가능한 Agentic AI 멀티 에이전트 플랫폼**으로 재정리하기 위한 개선 아이디어와 실행 계획을 정의합니다.
>
> 본 문서는 “어떻게 바꿀지(설계/원칙/구조/마이그레이션)”에 집중합니다.
> - 멀티 에이전트 공용 프레임워크는 [01.docs/10.agentic_architecture.md](10.agentic_architecture.md)를 기준으로 합니다.
> - Enterprise Intelligence 도메인 구성은 [01.docs/11.enterprise_intelligence_architecture.md](11.enterprise_intelligence_architecture.md)를 기준으로 합니다.

---

## 0. 문제 정의 (현재 상태)

현재 에이전트는 각각 목적에 맞춰 개별 최적화되어 잘 동작하지만, **연계/통합을 위한 공통 규약과 패키징이 약**합니다.

- 현재 구현된 에이전트(개념상)
  - 실시간 AI 채팅용 RAG 기반 검색 에이전트
  - RAG 검색 연동 PPT 생성 에이전트
  - KIPRIS API 기반 선행기술 검색 에이전트
- 추가 통합 예정
  - Text-to-SQL 에이전트(정형 데이터 질의/지식 창출)
  - 문서 RAG + Text-to-SQL + 외부 소스까지 연계하는 Deep Research 에이전트
  - 기술분석/예측(특허/기술별 토픽모델링, 네트워크 분석, 지식그래프 등) 확장 에이전트

핵심 문제는 다음 2가지입니다.

1) **문서 체계**: “Agentic AI 적용” 관점에서 공용 프레임워크/도메인/개별 에이전트 설계가 문서 상에서 분리·정렬되지 않아 확장 가이드가 약함
2) **디렉토리 체계**: 에이전트가 독립적인 응집도(프롬프트+그래프+도구+테스트)를 갖는 형태로 묶여 있지 않아, 신규 에이전트 추가 시 재사용/확장 경로가 불명확함

---

## 1. 목표 상태 (Target State)

### 1.1 Agentic AI 정의(프로젝트 기준)

이 프로젝트에서 “에이전트”는 다음 4요소를 함께 갖는 **제품 단위**로 정의합니다.

- **System Prompt (정책/역할/제약)**
- **State (입력/출력/메모리/메타데이터 스키마)**
- **Tools / Actions (외부 시스템 호출/내부 기능 실행)**
- **Graph (LangGraph 기반 실행 흐름: 노드/라우팅/재시도/종료 조건)**

즉, “에이전트 = prompt + state + tools + graph”가 한 덩어리로 버전업/테스트/운영될 수 있어야 합니다.

### 1.2 통합 원칙(확장/유지보수 관점)

- **단일 진입점**: Supervisor/Router는 개별 모듈을 직접 import하지 않고 **AgentCatalog**로만 후보/핸들러를 획득
- **Feature Pack(에이전트 단위 응집)**: 에이전트 기능은 `agents/features/<agent_name>/` 아래에 prompt/graph/tools/tests를 함께 둠
- **Import-safe**: 모듈 import 시 외부 서비스 초기화/네트워크 호출/백그라운드 태스크 시작 금지(노드 실행 시점 또는 앱 startup으로 지연)
- **테스트 게이트 유지**: 컨테이너 내 `unit → functional → integration` 단계 게이트를 변경 단위마다 지킴

### 1.3 구현 현황(요약)

- ✅ `SearchAgent`(Search RAG): `agents/features/search_rag/` feature-pack으로 1차 전환 완료
- ✅ `PresentationAgent`: feature-pack worker(`agents/features/presentation/`)로 Supervisor 워커 엔트리포인트 1차 전환
- ✅ `AgentCatalog.get_workers()`: feature-pack(`app.agents.features.*.worker.get_worker_specs`) discovery 적용(동일 키는 feature-pack이 우선)
- ✅ 레거시 호환: 기존 import 경로는 shim/re-export로 유지

---

## 2. 권장 아키텍처(Agentic AI + LangGraph)

### 2.1 상위 오케스트레이션: Supervisor + Worker Subgraph

- `SupervisorAgent`는 “대화/요청”을 받아 다음 중 하나를 선택합니다.
  - 특정 Worker(전문 에이전트)
  - FINISH
- 각 Worker는 “단일 노드 함수”가 아니라 **자체 LangGraph Subgraph**로 확장 가능해야 합니다.
  - 예) `SearchRAGAgentGraph`, `TextToSQLAgentGraph`, `DeepResearchAgentGraph`

권장 인터페이스(개념):
- Supervisor는 `AgentCatalog.get_workers()`에서 `WorkerSpec(name, description, node)` 목록을 받습니다.
- `node`는 (단일 함수) 또는 (Subgraph entrypoint)로 통일합니다.

### 2.2 지식/데이터 결합 전략: RAG + Text-to-SQL

“지식 창출”을 목표로 할 때, 문서 기반 RAG와 정형 데이터 질의를 **동일 대화/세션 컨텍스트**에서 결합해야 합니다.

- RAG: 비정형(문서)에서 근거 chunk + citation + answer_source
- Text-to-SQL: 정형(테이블)에서 SQL 생성/검증/실행/결과 요약 + provenance

결합의 핵심은 “출처/근거”의 통일입니다.
- 결과 스키마를 통일하여(예: `Evidence`), Supervisor/DeepResearch가 근거를 합쳐 최종 답변을 생성

추가로, 보고서에서 강조한 것처럼 **시맨틱 라우팅(semantic router)** 으로 쿼리를 아래처럼 분기하는 것을 권장합니다.
- `rag`: 문서/특허/선행기술 등 비정형 중심
- `sql`: 통계/수치/집계 등 정형 중심
- `hybrid`: 두 소스 모두 필요한 복합 질의

Text-to-SQL을 안정적으로 붙이기 위한 구성요소(권장):
- **Schema RAG**: 테이블/컬럼 메타데이터를 임베딩해 스키마 컨텍스트를 제공
- **Few-shot 예제**: 대표 질의-정답 SQL 예제를 포함(정확도/일관성 개선 목적)
- **SQL Guards**: 허용 테이블/컬럼, WHERE 누락/대량 조회, DDL/DML 차단 등 안전성 검증
- **Read-only 우선**: 운영 DB 보호를 위해 read-only replica 또는 권한 제한부터 시작

### 2.3 Deep Research 에이전트 위치

Deep Research는 “새로운 단일 기능”이라기보다 **오케스트레이션형 에이전트**입니다.

- 입력: 복합 질문(문서+DB+웹+특허 등)
- 동작: 계획 수립 → 소스별 조사(RAG/Text-to-SQL/외부) → 근거 정리 → 최종 보고
- 구현: LangGraph에서
  - planner 노드
  - gather nodes(RAG, SQL, web, patent)
  - synthesize 노드

운영 관점에서(보고서 기반) Deep Research는 토큰/비용 사용량이 급격히 증가할 수 있으므로, 아래 전략을 함께 설계하는 것을 권장합니다.
- **Snippet-first 추론**: 전체 문서를 모두 가져오기 전에 스니펫/요약으로 1차 판단
- **모델 라우팅**: 단순 분류/요약은 저렴한 모델, 합성/추론은 고성능 모델로 분리
- **시맨틱 캐싱**: 유사 질의/중간 산출물을 재사용(특히 웹/검색 결과)

### 2.4 LangGraph 2024-2025 패턴 반영(권장)

보고서에서 언급된 최신 패턴을, 본 프로젝트의 원칙(Import-safe/테스트 게이트)에 맞춰 선택적으로 반영합니다.

- **`Command` 반환 타입(권장)**: 노드가 상태 업데이트와 다음 노드 이동을 명시적으로 표현(핸드오프/분기 구현에 유리)
- **`InjectedState`(선택)**: 도구 호출 시 런타임 상태를 안전하게 주입(도구가 전역 상태에 의존하지 않도록)
- **Memory Store(선택)**: 크로스-세션 기억(선호도/이력)이나 “장기 메모리”를 분리해서 관리
- **Durable Execution(선택)**: 장애/재시작 시 중단 지점부터 재개 가능한 실행(체크포인터와 함께 고려)

현 코드베이스에서는 이미 import-time side effect를 제거하는 방향으로 정리되어 있으므로,
체크포인터/스토어는 **애플리케이션 startup 또는 노드 실행 시점**에만 구성하는 것을 유지합니다.

### 2.5 멀티에이전트 토폴로지 선택 가이드

보고서에서 정리한 토폴로지 중, IP 관리 솔루션에는 **Supervisor 패턴**을 기본으로 권장합니다.

- **Supervisor**: 중앙 라우팅/정책이 명확하고, 신규 에이전트(플러그인) 추가 시 운영이 단순
- **Swarm**: 에이전트 간 동적 핸드오프/연속 대화에 유리(필요 시 부분 도입)
- **Network**: P2P 협업/반복 정제에 유리하지만, 운영 복잡도가 높아 초기에는 비권장

추가로, 고수준 추상화가 필요할 경우 `langgraph-supervisor` 계열 라이브러리 패턴을 참고할 수 있으나,
본 프로젝트는 현재 `AgentCatalog` 중심으로 통합되어 있으므로 **카탈로그/워커 스펙을 단일 소스로 유지**하는 것을 우선합니다.

### 2.6 권장: 2단계 계층적 Supervisor(Team-of-Teams)

보고서의 결론을 반영하여, 에이전트 수가 늘어날수록(예: RAG, KIPRIS, SQL, Deep Research, PPT, Analytics...) 단일 Supervisor가 비대해지는 문제를 피하기 위해
**2단계 계층 구조**를 목표 아키텍처로 채택합니다.

- Top-Level Supervisor: 사용자 요청을 “팀(서브 슈퍼바이저)” 단위로 라우팅
- Team Supervisor: 팀 내부 Worker들 사이의 세부 라우팅 수행

권장 팀 구성(초기안):
- **Research Team**: Search RAG, KIPRIS(Prior Art), Text-to-SQL, Deep Research
- **Analysis Team(확장)**: Topic Modeling, Network Analysis, Knowledge Graph 등
- **Output Team**: Presentation(PPT), Report 생성 등

운영 권장사항(보고서 기반): 초기에는 관리 복잡도를 위해 **활성 워커 수를 작게(예: 5개 이하)** 시작하고, 팀 단위로 점진 확장합니다.

---

## 3. 에이전트 라인업(현재/추가 예정)과 역할 분해

### 3.1 현재(정리 대상)

- **Search RAG Agent**
  - 책임: 지식컨테이너/문서 기반 검색, 근거 생성, 답변 초안
- **Presentation Agent**
  - 책임: 검색 결과 기반 outline/slide 생성, PPT 파이프라인 오케스트레이션
- **Prior Art (KIPRIS) Agent**
  - 책임: KIPRIS 연계 검색/정리/분석(선행기술)

### 3.2 추가 예정(통합 방식 권장)

- **Text-to-SQL Agent**
  - 책임: 스키마 선택, SQL 생성/검증, 실행, 결과 요약, 근거 반환
  - 강제 규칙: read-only부터 시작(권한/감사/안전)
- **Deep Research Agent**
  - 책임: 복합 조사 플로우(문서+SQL+외부) 통합
- **Analytics Agents(토픽/네트워크/KG)**
  - 권장: “모든 분석을 에이전트로 만들기”보다, 1차로는
    - Tool(분석 함수) + 단일 Worker(분석 오케스트레이션)
    - 확장 시 전용 subgraph로 승격

### 3.3 통합 방식(보고서 기반) - Subgraph vs Wrapper

기존 에이전트들이 서로 다른 상태/입출력 스키마를 가진 경우가 많으므로, 통합은 아래 2가지 패턴을 명시적으로 사용합니다.

- **접근 A: 직접 서브그래프 통합**
  - 공용 상태 키를 공유할 수 있을 때, 각 에이전트를 Subgraph로 컴파일하여 부모 그래프에 노드로 추가
- **접근 B: 래퍼(어댑터) 함수**
  - 상태 스키마가 다를 때, 부모 상태 → 에이전트 입력 변환 / 에이전트 출력 → 부모 상태 업데이트를 수행

이 2가지 방식을 문서/코드 규약으로 고정하면, “각자는 잘 돌지만 연계는 어려운 상태”를 가장 빠르게 완화할 수 있습니다.

---

## 4. 디렉토리 재정리 제안 (에이전트 단위 응집)

### 4.1 현재 구조(관찰)

- `backend/app/agents/` 아래에 다양한 에이전트가 혼재
- `backend/app/tools/`는 도메인별 폴더가 있지만, “어떤 에이전트의 toolset인지”가 1:1로 드러나지 않음
- `backend/app/services/presentation/`는 구현이 방대하고 PresentationAgent와 결속이 강하지만, 에이전트 패키지와 분리되어 있어 경계가 모호함

### 4.2 목표 구조(제안): Feature Pack = Agent Unit

권장 디렉토리(제안):

```
backend/app/agents/
  core/                     # 공용 프레임워크(유지)
    catalog.py
    supervisor_agent.py
    core/workers.py
    core/db.py
    ...

  features/                 # 에이전트 단위 응집 패키지
    search_rag/
      prompt.md             # 시스템 프롬프트(단일 소스)
      state.py              # LangGraph state + IO schema
      graph.py              # LangGraph 정의(entrypoint)
      nodes.py              # node 구현(필요 시)
      toolkit.py            # 이 에이전트가 주로 쓰는 Tool 묶음
      README.md             # 목적/입출력/운영

    presentation/
      prompt.md
      state.py
      graph.py
      toolkit.py
      services/             # (선택) presentation 서비스 중 agent 결속 높은 것만 이동

    prior_art/
      prompt.md
      state.py
      graph.py
      toolkit.py

    text_to_sql/
      prompt.md
      state.py
      graph.py
      toolkit.py
      sql/                   # SQL 안전장치(validator, allowlist)

    deep_research/
      prompt.md
      state.py
      graph.py
      planner.py
      toolkit.py

  legacy/                   # 기존 경로 호환 래퍼(점진 제거)
    paper_search_agent.py -> features/search_rag/...
    presentation/... -> features/presentation/...
    patent/... -> features/prior_art/... (또는 enterprise/patent)
```

핵심은 **에이전트 폴더 안에서 prompt/graph/toolkit가 함께 유지**되는 것입니다.

---

## 5. Tools / Services 재정리 제안

### 5.1 Tools는 “에이전트가 사용하는 계약”으로

`backend/app/tools/`는 기능별로 이미 분리되어 있으나, 앞으로는 아래 2가지를 강화합니다.

- **tool contract(입력/출력/오류/근거 스키마)**를 공용으로 통일
- 특정 에이전트가 주로 쓰는 툴은 `agents/features/<agent>/toolkit.py`에서 “조합된 toolset”으로 제공

예시(개념):
- SearchRAGAgentToolkit = retrieval + rerank + context_builder
- TextToSQLAgentToolkit = schema_select + sql_gen + sql_validate + sql_execute
- DeepResearchToolkit = (SearchRAG + TextToSQL + Web + PriorArt)를 합성

### 5.2 presentation 서비스 경계 정리

`backend/app/services/presentation/`는 구현량이 많아 한 번에 이동하지 않고, 다음 원칙을 권장합니다.

- 에이전트가 호출하는 진입점은 `tool` 또는 `toolkit`에 집중
- `services/presentation` 내부 모듈은 에이전트 외부에서도 쓰일 수 있으므로 “무조건 이동”은 지양
- 대신 `agents/features/presentation/`에
  - prompt/state/graph/toolkit을 두고
  - toolkit이 `services/presentation`의 파사드(facade)를 호출하도록 경계를 명확히 함

### 5.3 Agent Registry/Capability Discovery(확장 기능 플러그인화)

보고서에서 제시한 **Agent Registry 패턴**은, 토픽모델링/네트워크분석/지식그래프 같은 분석 기능을 “플러그인처럼” 추가하는 데 유효합니다.

본 프로젝트에서는 이를 다음과 같이 해석해 반영하는 것을 권장합니다.
- 단일 레지스트리를 새로 만들기보다, 이미 도입된 **`AgentCatalog`를 확장**하여
  - `capabilities`(키워드/태그)
  - `discover_by_capability()`
  - (선택) `build_dynamic_graph(required_capabilities)`
  같은 기능을 제공

이렇게 하면 Supervisor/Team Supervisor는 “개별 에이전트 import”가 아니라 “요구 capability”로부터 후보를 찾고 실행할 수 있어, 분석 기능 확장이 단순해집니다.

---

## 6. 문서(10/11) 재정리 제안

### 6.1 10 문서(공용 프레임워크) 권장 목차(제안)

- Agentic AI 정의(이 프로젝트 기준: prompt/state/tools/graph)
- Supervisor/Worker 모델 + AgentCatalog
- State/Message/Evidence 스키마(표준)
- Tool contract 표준(입출력/근거/에러)
- Import-safe 원칙(필수)
- 테스트 게이트(필수)
- 디렉토리 운영 원칙(Feature Pack)
- Phase 0~3 로드맵(단일 소스)

### 6.2 11 문서(도메인 특화) 권장 구성(제안)

- Enterprise Intelligence의 “에이전트 라인업”과 capabilities
- 도메인 유즈케이스(특허/연구/시장)
- Deep Research/Analytics 확장 로드맵(도메인 관점)

---

## 7. 실행 계획(마이그레이션 단계)

> 원칙: 큰 리네이밍/대이동을 한 번에 하지 않고, **호환 래퍼(legacy) + 카탈로그 기반 discovery**로 점진 전환합니다.

### Step 1) 문서 체계 재정리(우선순위 1)

- 10/11 문서의 “공용 vs 도메인” 경계를 명확히 재배치
- 각 에이전트의 정의(역할/입출력/근거)를 동일 템플릿으로 정리

완료 기준:
- 신규 에이전트(Text-to-SQL/DeepResearch)를 추가할 때, 문서만 보고도
  - 어디에 코드를 두고
  - 어떤 contract를 맞추고
  - 어떤 테스트를 추가해야 하는지
  가 명확함

추가 완료 기준(보고서 반영):
- “Subgraph 통합 vs Wrapper 통합” 규약이 문서에 명확히 존재
- RAG/SQL/Hybrid 라우팅 기준(시맨틱 라우터)이 문서에 명확히 존재

### Step 2) 디렉토리 재정리(우선순위 2)

- `agents/features/<agent>/` 형태로 “에이전트 단위” 패키징을 시작
- 기존 import 경로는 `agents/legacy/` 또는 re-export로 호환 유지
- AgentCatalog의 worker discovery가 `features`를 우선 탐색하도록 확장(Phase 2)

완료 기준:
- SearchRAG / Presentation / PriorArt(KIPRIS) 중 최소 1개가 feature-pack 형태로 완전 이행
- unit/functional 테스트 게이트가 그대로 통과

### Step 3) Text-to-SQL → Deep Research 순으로 통합

- Text-to-SQL을 “단일 Worker”로 먼저 붙이고
- Deep Research는 “오케스트레이션형 subgraph”로 붙입니다.

추가 권장(보고서 반영):
- Text-to-SQL은 Schema RAG + SQL Guards + read-only부터 시작
- Deep Research는 snippet-first/모델 라우팅/캐싱을 초기부터 설계

### Step 4) 2단계 계층 Supervisor로 확장(Team-of-Teams)

- 단일 Supervisor가 비대해지기 전에, Research/Analysis/Output 팀 서브 슈퍼바이저를 도입
- Top-Level Supervisor는 “팀 라우팅”만 담당하도록 단순화
- 팀 단위로 worker 수를 관리(초기에는 활성 워커 수를 작게 유지)

완료 기준:
- Top-Level → Team Supervisor → Worker의 최소 성공 경로가 functional 테스트로 검증

---

## 8. 체크리스트(운영/품질)

- 모든 에이전트는 `prompt.md`를 가진다
- 모든 에이전트는 최소 1개의 unit test를 가진다
- Supervisor는 AgentCatalog로만 workers/tools/autonomous를 조회한다
- 모듈 import 시 외부 초기화가 없다(import-safe)
- `shell-script/test-backend-unit.sh` 및 `shell-script/test-backend-functional.sh`가 컨테이너에서 PASS

권장(보고서 반영):
- 노드 간 핸드오프/분기는 `Command`(또는 동등한 명시적 반환 규약)로 표현한다
- 세션 연속성(thread_id)과 체크포인터/스토어는 startup 또는 실행 시점에만 초기화한다

---

## 9. 변경/검증 프로세스(필수) — 테스트 게이트 + 문서 베이스라인 재정의

본 프로젝트의 리팩터링/확장 작업은 “코드 변경 → 테스트 검증 → 문서 업데이트 → 베이스라인 재정의”를 하나의 사이클로 운영합니다.

### 9.1 테스트 게이트 원칙(컨테이너 내부)

코드 변경 시 아래 순서를 **반드시** 따릅니다.

1) **단위 테스트(Unit)**
  - 변경한 모듈/함수의 로직을 가장 좁게 검증
  - 최소 기준: 변경사항을 재현/검증하는 unit test 1개 이상 추가 또는 갱신
  - 실행: `shell-script/test-backend-unit.sh`

2) **기능 테스트(Functional)**
  - API wiring / Supervisor-Worker 연결 / 핵심 유즈케이스 “최소 성공 경로”를 검증
  - 실행: `shell-script/test-backend-functional.sh`

3) **통합 테스트(Integration)**
  - 실DB/Redis/외부 의존성이 포함된 최소 시나리오(또는 스텁/테스트 더블)로 통합 경로 검증
  - 실행: `shell-script/test-backend-integration.sh`

### 9.2 재보완(보정) 루프

테스트 실패/회귀가 발생하면 다음 원칙으로 “재보완”합니다.

- **원인 분리**: 변경으로 인한 실패인지, 기존 불안정/환경 문제인지 구분
- **최소 수정**: 회귀를 막는 최소 변경으로 해결(범위 확장 금지)
- **재발 방지**: 같은 실패가 다시 나지 않도록 해당 케이스를 테스트로 고정
- **게이트 재통과**: unit → functional → integration 순서로 다시 통과

### 9.2.1 임시 하드코딩 관리(필수) — “원인 파악용” 코드는 반드시 복원

문제 원인 파악 과정에서 임시 하드코딩(예: 특정 provider 고정, 특정 ID/경로 고정, 라우팅 강제, 테스트용 더미 토큰 삽입 등)이 필요할 수 있습니다.
다만 해당 하드코딩이 운영 코드에 남는 것은 심각한 회귀/보안/운영 장애를 유발하므로 아래 규칙을 강제합니다.

허용되는 임시 하드코딩의 형태(권장):
- **테스트 코드에서만** 하드코딩(예: fixture/monkeypatch)
- 프로덕션 코드에 들어가야 한다면
  - **명시적 플래그/설정으로만 활성화**(기본 OFF)
  - 기능 플래그/환경변수 이름이 “디버그 전용”임을 드러내야 함

금지(원칙):
- 프로덕션 경로에서 기본값이 하드코딩을 활성화
- 특정 사용자/컨테이너/문서 ID, API 키/토큰/엔드포인트를 코드에 박아 넣기
- 라우팅/모델 선택/권한 체크를 우회하는 하드코딩

복원(restore) 절차(필수):
1) 임시 하드코딩을 제거하거나, 기본 OFF인 설정/플래그 뒤로 숨김
2) “왜 이 하드코딩이 필요했는지”에 대응하는 **재발 방지 테스트**를 추가
3) 아래의 **하드코딩 잔존 검출 테스트**를 통과

### 9.3 문서 업데이트(필수) — 베이스라인 재정의

각 Phase/주요 리팩터링 단위가 완료될 때마다, 문서가 “현재 기준(베이스라인)”을 대표하도록 업데이트합니다.

필수 업데이트 대상(원칙):
- 공용 프레임워크 변경(오케스트레이션/상태/툴 계약/디렉토리 규약): [01.docs/10.agentic_architecture.md](10.agentic_architecture.md)
- 도메인 에이전트 라인업/유즈케이스/로드맵: [01.docs/11.enterprise_intelligence_architecture.md](11.enterprise_intelligence_architecture.md)
- 본 개선 계획/마이그레이션 기준: [01.docs/21.agentic_ai_refactor_plan.md](21.agentic_ai_refactor_plan.md)

문서 업데이트 최소 기준:
- **Change Log**에 날짜/요약/범위 반영
- **"현재 기준" 섹션** 또는 해당 Phase 상태를 최신으로 유지(예: Phase 완료 체크)
- 코드 구조가 바뀌면 **디렉토리/진입점/권장 import 경로**를 문서에서 즉시 갱신

### 9.4 PR/릴리즈 수준 체크(권장)

- 테스트 스크립트 3종(unit/functional/integration) 모두 PASS 결과를 남김
- 문서(10/11/21) 중 영향을 받는 문서는 함께 업데이트(“코드는 변했는데 문서는 옛날 상태” 방지)

---

## 10. 하드코딩 잔존 여부 검출(테스트 시나리오 필수 포함)

원인 파악을 위해 잠시 넣었던 하드코딩이 잔존하는지 여부를, 테스트로 자동 검출하도록 시나리오에 포함합니다.

### 10.1 Unit 테스트 시나리오(필수)

- **정책/라우팅 하드코딩 금지 검출**
  - 예: 특정 worker/model/provider를 강제로 선택하는 코드가 남아 있지 않은지 검증
- **설정 기반 동작 보장**
  - 예: provider 선택/라우팅/엔드포인트가 설정으로만 결정되고, 코드 상수로 고정되지 않음을 검증
- **"금지 마커" 스캔(권장)**
  - 임시 디버그용 코드를 남겨야 할 경우, 명시적 마커(예: `TEMP_HARDCODE_ONLY`, `DEBUG_ONLY`)를 사용하고
    unit 테스트에서 해당 마커가 **프로덕션 모듈에 존재하면 실패**하도록 고정

### 10.2 Functional 테스트 시나리오(필수)

- **E2E 경로에서 강제 라우팅/강제 provider가 작동하지 않음**
  - 예: `/agent/chat` 호출 시, 환경설정이 바뀌면 라우팅/모델 선택이 그에 따라 달라져야 함
- **폴백 동작이 자연스러움**
  - 예: LLM 누락/외부 의존성 누락 상황에서, 임시 우회(hardcode)로 성공하는 것이 아니라
    명시된 폴백 정책(문서/코드)에 따라 동작해야 함

### 10.3 운영 전 최종 확인(권장)

- 코드 리뷰 체크리스트에 “임시 하드코딩 제거/플래그 기본 OFF/테스트 포함” 항목을 포함
- 영향 큰 영역(보안/권한/모델 라우팅/외부 API)은 integration 테스트까지 포함해 재검증

---

## 9. 다음 액션(추천)

1) (문서) 10/11의 목차/섹션을 위 제안 기준으로 재배치(대규모 리라이트)
2) (코드) `agents/features/search_rag/`부터 1개 에이전트를 feature-pack으로 이행
3) (설계) Text-to-SQL Agent contract(Evidence/Result 스키마, SQL 안전장치) 확정

