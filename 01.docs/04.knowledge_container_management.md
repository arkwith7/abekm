# 04. IP í¬íŠ¸í´ë¦¬ì˜¤ ê´€ë¦¬ ì‹œìŠ¤í…œ (êµ¬ ì§€ì‹ ì»¨í…Œì´ë„ˆ)

> **ìµœì¢… ì—…ë°ì´íŠ¸**: 2026-01-04  
> **ì£¼ìš” ë³€ê²½**:
> - "ì§€ì‹ ì»¨í…Œì´ë„ˆ" ê°œë…ì„ "IP í¬íŠ¸í´ë¦¬ì˜¤"ë¡œ í™•ì¥ ë° ê³ ë„í™”
> - "IP í¬íŠ¸í´ë¦¬ì˜¤" ë©”ë‰´ëŠ” **IPC/CPC ê¸°ìˆ  ë¶„ë¥˜ ì²´ê³„**ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ìš´ì˜ (ì¡°ì§ë„ ê¸°ë°˜ ì»¨í…Œì´ë„ˆ/SAP ì—°ë™ì€ ë ˆê±°ì‹œ/ì„ íƒ)
> - íŠ¹í—ˆ ë¬¸ì„œ íŠ¹í™” ë©”íƒ€ë°ì´í„° ë° ì‹œê°í™”(íŠ¹í—ˆ ì¹´ë“œ) ë„ì…
> - **Phase 1~3 êµ¬í˜„ ì™„ë£Œ** (2026-01-04): IPC ê¶Œí•œ ì„œë¹„ìŠ¤, IP í¬íŠ¸í´ë¦¬ì˜¤ API, í”„ë¡ íŠ¸ì—”ë“œ UI

## 0. êµ¬í˜„ í˜„í™© ìš”ì•½ (2026-01-04)

### âœ… ì™„ë£Œëœ êµ¬í˜„

#### ë°±ì—”ë“œ
- **ë°ì´í„°ë² ì´ìŠ¤**: `tb_ipc_permissions` ìƒì„± (IPC ì½”ë“œë³„ ì‚¬ìš©ì ê¶Œí•œ)
- **ì„œë¹„ìŠ¤**: `IpcPermissionService` (ê¶Œí•œ ë¡œì§, ì¬ê·€ CTE, í•˜ìœ„ ì½”ë“œ í¬í•¨)
- **API ë¼ìš°í„°**: 
  - `/api/v1/admin/ipc/*`: IPC ê´€ë¦¬ API (6ê°œ ì—”ë“œí¬ì¸íŠ¸)
  - `/api/v1/ip-portfolio/*`: IP í¬íŠ¸í´ë¦¬ì˜¤ API (6ê°œ ì—”ë“œí¬ì¸íŠ¸)
    - my-permissions, ipc-tree, patents, patents/{id}, dashboard-stats
- **í…ŒìŠ¤íŠ¸**: ë‹¨ìœ„/ê¸°ëŠ¥/í†µí•© í…ŒìŠ¤íŠ¸ ì™„ë£Œ (22/24 PASS)

#### í”„ë¡ íŠ¸ì—”ë“œ
- **í˜ì´ì§€**: `/user/ip-portfolio` (IPPortfolioPage.tsx)
- **UI êµ¬ì„±**: IPC íŠ¸ë¦¬ ì‚¬ì´ë“œë°” + íŠ¹í—ˆ ì¹´ë“œ ê·¸ë¦¬ë“œ + ëŒ€ì‹œë³´ë“œ í†µê³„
- **ì„œë¹„ìŠ¤**: ipPortfolioService.ts (API í´ë¼ì´ì–¸íŠ¸)
- **ë¼ìš°íŒ…**: App.tsxì— ë¼ìš°íŠ¸ ë“±ë¡

### ğŸ”œ ë‹¤ìŒ ë‹¨ê³„

**IP í¬íŠ¸í´ë¦¬ì˜¤ 2ë‹¨ê³„ ê¶Œí•œ ì²´ê³„ í™•ì •** â­
- Phase 1: ì‚¬ìš©ì (VIEWER/EDITOR) + ì‹œìŠ¤í…œ ê´€ë¦¬ì (ADMIN)
- MANAGER ì—­í• ì€ ë°ì´í„° ëª¨ë¸ì—ë§Œ ì¡´ì¬, UIëŠ” Phase 2 ì´í›„

1. **ì‹œìŠ¤í…œ ê´€ë¦¬ì IPC ê¶Œí•œ ê´€ë¦¬ UI** (`/admin/ipc-permissions`) - ìµœìš°ì„ 
   - ì‚¬ìš©ìë³„ IPC ê¶Œí•œ ì§ì ‘ í• ë‹¹
   - ê¶Œí•œ ë ˆë²¨: VIEWER/EDITOR/ADMIN
   - í•˜ìœ„ ì½”ë“œ í¬í•¨ ì˜µì…˜
2. íŠ¹í—ˆ ìƒì„¸ í˜ì´ì§€ (ì²­êµ¬í•­, ìœ ì‚¬ íŠ¹í—ˆ)
3. ëŒ€ì‹œë³´ë“œ ì°¨íŠ¸ ê³ ë„í™” (ì¸í„°ë™í‹°ë¸Œ, ë“œë¦´ë‹¤ìš´)
4. IPC ìë™ ë¶„ë¥˜ ë¡œì§ (TF-IDF/ì„ë² ë”©)
5. (ì„ íƒ) ê¶Œí•œ ìš”ì²­ ì›Œí¬í”Œë¡œìš° ë° MANAGER ì—­í•  UI (Phase 2+)

---

## 1. ì‹œìŠ¤í…œ ê°œìš”

### 1.1 ëª©ì 

IPBridgeì˜ IP í¬íŠ¸í´ë¦¬ì˜¤ ê´€ë¦¬ ì‹œìŠ¤í…œì€ ê¸°ì¡´ì˜ ì¡°ì§ë„ ê¸°ë°˜ ì§€ì‹ ì €ì¥ì†Œë¥¼ ë„˜ì–´, **êµ­ì œíŠ¹í—ˆë¶„ë¥˜(IPC) ë° í˜‘ë ¥íŠ¹í—ˆë¶„ë¥˜(CPC)** ê¸°ë°˜ì˜ ì²´ê³„ì ì¸ íŠ¹í—ˆ ìì‚° ê´€ë¦¬ë¥¼ ì§€ì›í•©ë‹ˆë‹¤. ì´ë¥¼ í†µí•´ ê¸°ì—…ì˜ ê¸°ìˆ  ìì‚°ì„ í‘œì¤€í™”ëœ ì²´ê³„ë¡œ ë¶„ë¥˜í•˜ê³ , ê²½ìŸì‚¬ì™€ì˜ ë¹„êµ ë¶„ì„ ë° ì „ëµì  ì˜ì‚¬ê²°ì •ì„ ì§€ì›í•©ë‹ˆë‹¤.

### 1.2 IP í¬íŠ¸í´ë¦¬ì˜¤ ê°œë…

- **ê¸°ìˆ  ë¶„ë¥˜ ì»¨í…Œì´ë„ˆ**: IPC/CPC ì½”ë“œë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•œ í‘œì¤€í™”ëœ ì§€ì‹ ì €ì¥ ë‹¨ìœ„ (ì˜ˆ: H04W, G06N)
- **ì»¤ìŠ¤í…€ ë§¤í•‘**: ê¸°ì—… ë‚´ë¶€ ìš©ì–´(ì˜ˆ: "ì°¨ì„¸ëŒ€ ë°°í„°ë¦¬")ë¥¼ í‘œì¤€ IPC ì½”ë“œì™€ ë§¤í•‘í•˜ì—¬ ê°€ìƒ í´ë” ì œê³µ
- **íŠ¹í—ˆ ì¤‘ì‹¬ ë©”íƒ€ë°ì´í„°**: ì¶œì›ë²ˆí˜¸, ì¶œì›ì¼, ë²•ì ìƒíƒœ, ì²­êµ¬í•­ ë“± íŠ¹í—ˆ íŠ¹í™” ì†ì„± ê´€ë¦¬
- **ìë™ ë¶„ë¥˜**: ë¬¸ì„œ ì—…ë¡œë“œ ì‹œ í…ìŠ¤íŠ¸ ë¶„ì„ì„ í†µí•´ ì ì ˆí•œ IPC/CPC ì½”ë“œë¡œ ìë™ ë¶„ë¥˜ ë° íƒœê¹…

### 1.3 ì‹œìŠ¤í…œ ë²”ìœ„

- **IPC/CPC í‘œì¤€ ë¶„ë¥˜ ì²´ê³„ êµ¬ì¶•**: 8ê°œ ì„¹ì…˜ ë° í•˜ìœ„ í´ë˜ìŠ¤ DB êµ¬ì¶•
- **íŠ¹í—ˆ ë¬¸ì„œ ì¹´ë“œ(Patent Card)**: ì¸ë„¤ì¼, ë²•ì ìƒíƒœ, í•µì‹¬ í‚¤ì›Œë“œ ë“±ì„ ì‹œê°í™”í•œ UI
- **ìë™ ë¶„ë¥˜ ì—”ì§„**: í…ìŠ¤íŠ¸ ê¸°ë°˜ IPC ì¶”ì²œ ë° ìë™ íŒŒì¼ë§
- **ê¶Œí•œ ê´€ë¦¬**: ê¸°ìˆ  ë¶„ì•¼ë³„/í”„ë¡œì íŠ¸ë³„ ì ‘ê·¼ ì œì–´ (ê¸°ì¡´ ì¡°ì§ ê¶Œí•œê³¼ í•˜ì´ë¸Œë¦¬ë“œ ìš´ìš©)
- **í¬íŠ¸í´ë¦¬ì˜¤ ì‹œê°í™”**: ê¸°ìˆ  ë¶„ì•¼ë³„ íŠ¹í—ˆ ë¶„í¬ ë„ë„› ì°¨íŠ¸, ì—°ë„ë³„ ì¶œì› ì¶”ì´ ê·¸ë˜í”„

## 2. ì•„í‚¤í…ì²˜ ì„¤ê³„

### 2.1 ì „ì²´ ì•„í‚¤í…ì²˜

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   User Auth     â”‚â”€â”€â”€â”€â”€â”€â”€â–¶â”‚  IPC Permission â”‚â”€â”€â”€â”€â”€â”€â”€â–¶â”‚   IP Portfolio  â”‚
â”‚ (get_current_user)       â”‚ (tb_ipc_permissions)      â”‚   API Layer     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚ (/ip-portfolio) â”‚
         â”‚                               â”‚             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â–¼                               â–¼                       â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â–¼
â”‚  IPC Master     â”‚â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Patent Metadata â”‚        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (tb_ipc_code)   â”‚        â”‚ (tb_patent_metadata)      â”‚ Visualization & â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚   Analytics     â”‚
                                                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

(ë ˆê±°ì‹œ/ì„ íƒ) SAP ì¡°ì§ë„/ì§€ì‹ ì»¨í…Œì´ë„ˆ ê¸°ë°˜ êµ¬ì¡°ëŠ” ê¸°ì¡´ ë¬¸ì„œ ê´€ë¦¬ ëª©ì ì¼ ë•Œë§Œ ìœ ì§€
```

### 2.2 ì§€ì‹ ì»¨í…Œì´ë„ˆ êµ¬ì¡°

> **ì°¸ê³ (ë ˆê±°ì‹œ)**: ì•„ë˜ ì¡°ì§ë„ ê¸°ë°˜ ì»¨í…Œì´ë„ˆ êµ¬ì¡°ëŠ” ê¸°ì¡´ ì§€ì‹/ë¬¸ì„œ ê´€ë¦¬ì˜ ê³„ì¸µ í‘œí˜„ì´ë©°,
> "IP í¬íŠ¸í´ë¦¬ì˜¤" ë©”ë‰´ì˜ ì£¼ ë„¤ë¹„ê²Œì´ì…˜/ê¶Œí•œ ê¸°ì¤€ì€ **IPC ë¶„ë¥˜ ì²´ê³„**ì…ë‹ˆë‹¤.

```
íšŒì‚¬ (ROOT)
â”œâ”€â”€ ê²½ì˜ì§„ (ì„ì›ì§„ ì§€ì‹)
â”‚   â”œâ”€â”€ CEO ì „ëµ ë¬¸ì„œ
â”‚   â””â”€â”€ ì´ì‚¬íšŒ ì˜ì‚¬ë¡
â”œâ”€â”€ ê¸°ìˆ ë³¸ë¶€ (ê¸°ìˆ  ì§€ì‹)
â”‚   â”œâ”€â”€ R&Dì„¼í„°
â”‚   â”‚   â”œâ”€â”€ AIíŒ€ (AI/ML ì§€ì‹)
â”‚   â”‚   â”œâ”€â”€ í”Œë«í¼íŒ€ (ì¸í”„ë¼ ì§€ì‹)
â”‚   â”‚   â””â”€â”€ í’ˆì§ˆê´€ë¦¬íŒ€ (QA ì§€ì‹)
â”‚   â””â”€â”€ ê°œë°œ1íŒ€ (ê°œë°œ ì§€ì‹)
â”œâ”€â”€ ì˜ì—…ë³¸ë¶€ (ì˜ì—… ì§€ì‹)
â”‚   â”œâ”€â”€ êµ­ë‚´ì˜ì—…íŒ€
â”‚   â””â”€â”€ í•´ì™¸ì˜ì—…íŒ€
â””â”€â”€ ì§€ì›ë³¸ë¶€ (ê´€ë¦¬ ì§€ì‹)
    â”œâ”€â”€ ì¸ì‚¬íŒ€ (HR ì§€ì‹)
    â”œâ”€â”€ ì¬ë¬´íŒ€ (ì¬ë¬´ ì§€ì‹)
    â””â”€â”€ ë²•ë¬´íŒ€ (ë²•ë¬´ ì§€ì‹)
```

## 3. ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„

### 3.1 IPC ì¤‘ì‹¬ IP í¬íŠ¸í´ë¦¬ì˜¤ ìŠ¤í‚¤ë§ˆ (ë©”ì¸)

```sql
-- IPC ì½”ë“œ ë§ˆìŠ¤í„° (ì´ë¯¸ êµ¬ì¶•)
-- tb_ipc_code

-- íŠ¹í—ˆ ë©”íƒ€ë°ì´í„° (ì´ë¯¸ êµ¬ì¶•)
-- tb_patent_metadata

-- IPC ì½”ë“œë³„ ì‚¬ìš©ì ê¶Œí•œ (ì‹ ê·œ)
CREATE TABLE tb_ipc_permissions (
    permission_id SERIAL PRIMARY KEY,
    user_emp_no VARCHAR(20) NOT NULL REFERENCES tb_user(emp_no),
    ipc_code VARCHAR(20) NOT NULL REFERENCES tb_ipc_code(code),
    role_id VARCHAR(20) NOT NULL,            -- ADMIN/MANAGER/EDITOR/VIEWER
    access_scope VARCHAR(20) DEFAULT 'FULL', -- FULL/READ_ONLY/WRITE_ONLY
    include_children BOOLEAN DEFAULT true,
    valid_from TIMESTAMP DEFAULT now(),
    valid_until TIMESTAMP,
    is_active BOOLEAN DEFAULT true,
    created_date TIMESTAMP DEFAULT now(),
    created_by VARCHAR(20),
    UNIQUE(user_emp_no, ipc_code)
);

CREATE INDEX idx_ipc_perm_user ON tb_ipc_permissions(user_emp_no);
CREATE INDEX idx_ipc_perm_code ON tb_ipc_permissions(ipc_code);
CREATE INDEX idx_ipc_perm_active ON tb_ipc_permissions(is_active, valid_until);

-- tb_patent_metadata ìµœì†Œ í™•ì¥ (ë ˆê±°ì‹œ ì¡°ì§ ì»¨í…Œì´ë„ˆ ì°¸ì¡° ë³´ì¡´ + IPC í•„í„°ìš©)
ALTER TABLE tb_patent_metadata
ADD COLUMN legacy_container_id VARCHAR(50),
ADD COLUMN primary_ipc_section VARCHAR(10),
ADD COLUMN keywords TEXT[];

CREATE INDEX idx_patent_meta_ipc_section ON tb_patent_metadata(primary_ipc_section);
CREATE INDEX idx_patent_meta_keywords ON tb_patent_metadata USING gin(keywords);
CREATE INDEX idx_patent_meta_legacy_container ON tb_patent_metadata(legacy_container_id);
```

### 3.2 (ë ˆê±°ì‹œ) ì¡°ì§ë„ ê¸°ë°˜ ì§€ì‹ ì»¨í…Œì´ë„ˆ ìŠ¤í‚¤ë§ˆ

```sql
-- ì§€ì‹ ì»¨í…Œì´ë„ˆ í…Œì´ë¸” (ì¡°ì§ë„ ê¸°ë°˜)
CREATE TABLE tb_knowledge_containers (
    container_id SERIAL PRIMARY KEY,
    container_name VARCHAR(100) NOT NULL,
    container_code VARCHAR(20) UNIQUE NOT NULL,
    parent_container_id INTEGER REFERENCES tb_knowledge_containers(container_id),
    
    -- SAP ì¡°ì§ ì •ë³´ ì—°ë™
    sap_org_code VARCHAR(20),
    sap_cost_center VARCHAR(20),
    org_level INTEGER NOT NULL DEFAULT 1,
    org_path TEXT, -- ê³„ì¸µ ê²½ë¡œ (ì˜ˆ: /ROOT/ê¸°ìˆ ë³¸ë¶€/R&Dì„¼í„°/AIíŒ€)
    
    -- ì»¨í…Œì´ë„ˆ ë©”íƒ€ë°ì´í„°
    description TEXT,
    container_type VARCHAR(20) DEFAULT 'department', -- department, team, project
    knowledge_category VARCHAR(50), -- ì£¼ìš” ì§€ì‹ ë¶„ì•¼
    
    -- ê¶Œí•œ ì„¤ì • ê°•í™”
    access_level VARCHAR(20) DEFAULT 'internal', -- public, internal, restricted, confidential
    default_permission VARCHAR(20) DEFAULT 'VIEWER', -- ê¸°ë³¸ ê¶Œí•œ ë ˆë²¨
    inherit_parent_permissions BOOLEAN DEFAULT true, -- ìƒìœ„ ì»¨í…Œì´ë„ˆ ê¶Œí•œ ìƒì†
    permission_inheritance_type VARCHAR(20) DEFAULT 'additive', -- additive, override
    
    -- ê¶Œí•œ ê´€ë¦¬ì ì„¤ì •
    container_owner VARCHAR(20), -- ì»¨í…Œì´ë„ˆ ì†Œìœ ì (ADMIN ê¶Œí•œ)
    permission_managers TEXT[], -- ê¶Œí•œ ê´€ë¦¬ì ëª©ë¡
    auto_assign_by_org BOOLEAN DEFAULT true, -- ì¡°ì§ë„ ê¸°ë°˜ ìë™ ê¶Œí•œ í• ë‹¹
    
    -- ìŠ¹ì¸ ì›Œí¬í”Œë¡œìš° ì„¤ì •
    require_approval_for_access BOOLEAN DEFAULT false, -- ì ‘ê·¼ ì‹œ ìŠ¹ì¸ í•„ìš”
    approval_workflow_enabled BOOLEAN DEFAULT false, -- ê¶Œí•œ ìš”ì²­ ìŠ¹ì¸ ì›Œí¬í”Œë¡œìš°
    approvers TEXT[], -- ìŠ¹ì¸ì ëª©ë¡
    
    is_active BOOLEAN DEFAULT true,
    
    -- ì§€ì‹ í†µê³„
    document_count INTEGER DEFAULT 0,
    total_knowledge_size BIGINT DEFAULT 0,
    last_knowledge_update TIMESTAMP,
    
    -- ê¶Œí•œ í†µê³„
    user_count INTEGER DEFAULT 0, -- ì ‘ê·¼ ê¶Œí•œì´ ìˆëŠ” ì‚¬ìš©ì ìˆ˜
    permission_request_count INTEGER DEFAULT 0, -- ê¶Œí•œ ìš”ì²­ ê±´ìˆ˜
    last_permission_update TIMESTAMP, -- ë§ˆì§€ë§‰ ê¶Œí•œ ë³€ê²½ ì‹œê°„
    
    -- ì‹œê°„ ì •ë³´
    created_date TIMESTAMP DEFAULT now(),
    created_by VARCHAR(20),
    last_modified_date TIMESTAMP DEFAULT now(),
    last_modified_by VARCHAR(20)
);

-- ê³„ì¸µêµ¬ì¡° ìµœì í™” ì¸ë±ìŠ¤
CREATE INDEX idx_containers_parent ON tb_knowledge_containers(parent_container_id);
CREATE INDEX idx_containers_path ON tb_knowledge_containers USING gin(org_path gin_trgm_ops);
CREATE INDEX idx_containers_sap ON tb_knowledge_containers(sap_org_code);

-- ì¬ê·€ CTEë¥¼ ìœ„í•œ í•¨ìˆ˜í˜• ì¸ë±ìŠ¤
CREATE INDEX idx_containers_hierarchy ON tb_knowledge_containers(container_id, parent_container_id);
```

### 3.2 ì§€ì‹ ë¶„ë¥˜ ë° ì¹´í…Œê³ ë¦¬

```sql
-- ì§€ì‹ ë¶„ë¥˜ ì²´ê³„
CREATE TABLE tb_knowledge_categories (
    category_id SERIAL PRIMARY KEY,
    category_name VARCHAR(100) NOT NULL,
    category_code VARCHAR(20) UNIQUE NOT NULL,
    parent_category_id INTEGER REFERENCES tb_knowledge_categories(category_id),
    
    -- ë¶„ë¥˜ ë©”íƒ€ë°ì´í„°
    description TEXT,
    category_level INTEGER DEFAULT 1,
    category_path TEXT, -- /ê¸°ìˆ /ê°œë°œ/AI
    
    -- ë¶„ë¥˜ë³„ íŠ¹ì„±
    knowledge_type VARCHAR(30), -- document, procedure, policy, manual, reference
    content_format VARCHAR(30), -- text, image, video, mixed
    update_frequency VARCHAR(20), -- daily, weekly, monthly, yearly, static
    
    -- ìë™ ë¶„ë¥˜ ì§€ì›
    keywords TEXT[], -- ìë™ ë¶„ë¥˜ë¥¼ ìœ„í•œ í‚¤ì›Œë“œ
    classification_rules JSONB, -- ìë™ ë¶„ë¥˜ ê·œì¹™
    
    is_active BOOLEAN DEFAULT true,
    created_date TIMESTAMP DEFAULT now()
);

-- ì»¨í…Œì´ë„ˆ-ì¹´í…Œê³ ë¦¬ ë§¤í•‘
CREATE TABLE tb_container_categories (
    mapping_id SERIAL PRIMARY KEY,
    container_id INTEGER REFERENCES tb_knowledge_containers(container_id),
    category_id INTEGER REFERENCES tb_knowledge_categories(category_id),
    
    -- ë§¤í•‘ ì†ì„±
    is_primary BOOLEAN DEFAULT false, -- ì£¼ìš” ì¹´í…Œê³ ë¦¬ ì—¬ë¶€
    weight FLOAT DEFAULT 1.0, -- ì¹´í…Œê³ ë¦¬ ê°€ì¤‘ì¹˜
    auto_assigned BOOLEAN DEFAULT false, -- ìë™ í• ë‹¹ ì—¬ë¶€
    
    created_date TIMESTAMP DEFAULT now(),
    
    UNIQUE(container_id, category_id)
);
```

### 3.3 ë¬¸ì„œ-ì»¨í…Œì´ë„ˆ ì—°ê²°

```sql
-- ê¸°ì¡´ íŒŒì¼ ì •ë³´ í…Œì´ë¸”ì— ì»¨í…Œì´ë„ˆ ì •ë³´ ì¶”ê°€
ALTER TABLE tb_file_bss_info 
ADD COLUMN knowledge_container_id INTEGER REFERENCES tb_knowledge_containers(container_id);
ADD COLUMN primary_category_id INTEGER REFERENCES tb_knowledge_categories(category_id);
ADD COLUMN secondary_categories INTEGER[]; -- ë³´ì¡° ì¹´í…Œê³ ë¦¬ë“¤

-- ê²€ìƒ‰ ë¬¸ì„œ í…Œì´ë¸”ì—ë„ ì»¨í…Œì´ë„ˆ ì •ë³´ ì¶”ê°€ (ì´ë¯¸ ì¶”ê°€ë¨)
-- ALTER TABLE tb_search_documents 
-- ADD COLUMN knowledge_container_id INTEGER REFERENCES tb_knowledge_containers(container_id);

-- ì»¨í…Œì´ë„ˆë³„ ë¬¸ì„œ í†µê³„ ë·°
CREATE VIEW vw_container_document_stats AS
SELECT 
    kc.container_id,
    kc.container_name,
    kc.org_path,
    COUNT(fb.FILE_BSS_INFO_SNO) as document_count,
    SUM(fb.FILE_SIZE) as total_size,
    MAX(fb.LAST_MODIFIED_DATE) as last_update,
    COUNT(DISTINCT fb.primary_category_id) as category_count
FROM tb_knowledge_containers kc
LEFT JOIN tb_file_bss_info fb ON kc.container_id = fb.knowledge_container_id
WHERE kc.is_active = true
GROUP BY kc.container_id, kc.container_name, kc.org_path;
```

## 4. SAP ì¡°ì§ë„ ì—°ë™

### 4.1 SAP RFC ê¸°ë°˜ ì¡°ì§ êµ¬ì¡° ë™ê¸°í™”

```python
class SAPOrganizationSync:
    def __init__(self):
        self.sap_connector = SAPRFCConnector()
        self.db = get_database()
    
    async def sync_organization_structure(self) -> dict:
        """SAP ì¡°ì§ë„ë¥¼ ì§€ì‹ ì»¨í…Œì´ë„ˆë¡œ ë™ê¸°í™”"""
        
        try:
            # 1. SAPì—ì„œ ì¡°ì§ êµ¬ì¡° ì¡°íšŒ
            sap_org_data = await self.sap_connector.get_organization_structure()
            
            # 2. ê¸°ì¡´ ì»¨í…Œì´ë„ˆì™€ ë¹„êµ
            existing_containers = await self.get_existing_containers()
            
            # 3. ë³€ê²½ì‚¬í•­ ë¶„ì„
            changes = self.analyze_organization_changes(sap_org_data, existing_containers)
            
            # 4. ì»¨í…Œì´ë„ˆ ìƒì„±/ìˆ˜ì •/ë¹„í™œì„±í™”
            sync_results = await self.apply_organization_changes(changes)
            
            # 5. ê¶Œí•œ ì¬ì„¤ì •
            await self.update_container_permissions(sync_results)
            
            return {
                "status": "success",
                "containers_created": sync_results["created"],
                "containers_updated": sync_results["updated"],
                "containers_deactivated": sync_results["deactivated"],
                "sync_timestamp": datetime.now().isoformat()
            }
            
        except Exception as e:
            logger.error(f"SAP ì¡°ì§ë„ ë™ê¸°í™” ì‹¤íŒ¨: {e}")
            return {"status": "failed", "error": str(e)}
    
    async def create_knowledge_container(self, sap_org: dict, parent_id: int = None) -> int:
        """SAP ì¡°ì§ ì •ë³´ë¡œ ì§€ì‹ ì»¨í…Œì´ë„ˆ ìƒì„±"""
        
        container_data = {
            "container_name": sap_org["org_name"],
            "container_code": sap_org["org_code"],
            "parent_container_id": parent_id,
            "sap_org_code": sap_org["sap_code"],
            "sap_cost_center": sap_org.get("cost_center"),
            "org_level": sap_org["level"],
            "org_path": self.build_org_path(sap_org, parent_id),
            "description": sap_org.get("description", ""),
            "container_type": self.determine_container_type(sap_org),
            "knowledge_category": self.determine_knowledge_category(sap_org),
            "access_level": self.determine_access_level(sap_org),
            "created_by": "system_sync"
        }
        
        query = """
        INSERT INTO tb_knowledge_containers 
        (container_name, container_code, parent_container_id, sap_org_code, 
         sap_cost_center, org_level, org_path, description, container_type, 
         knowledge_category, access_level, created_by)
        VALUES 
        (:container_name, :container_code, :parent_container_id, :sap_org_code,
         :sap_cost_center, :org_level, :org_path, :description, :container_type,
         :knowledge_category, :access_level, :created_by)
        RETURNING container_id
        """
        
        result = await self.db.fetch_one(query, container_data)
        return result["container_id"]
```

### 4.2 ì¡°ì§ ê³„ì¸µ êµ¬ì¡° ê´€ë¦¬

```python
class OrganizationHierarchyManager:
    def __init__(self):
        self.db = get_database()
        self.permission_service = PermissionService()
    
    async def get_container_hierarchy(self, 
                                    container_id: int = None,
                                    user_id: str = None,
                                    include_permissions: bool = True) -> dict:
        """ì‚¬ìš©ì ê¶Œí•œ ê¸°ë°˜ ì»¨í…Œì´ë„ˆ ê³„ì¸µ êµ¬ì¡° ì¡°íšŒ"""
        
        if container_id:
            # íŠ¹ì • ì»¨í…Œì´ë„ˆì˜ í•˜ìœ„ êµ¬ì¡° (ê¶Œí•œ í™•ì¸ í¬í•¨)
            query = """
            WITH RECURSIVE container_tree AS (
                SELECT c.container_id, c.container_name, c.parent_container_id, 
                       c.org_level, c.org_path, c.access_level, 0 as depth,
                       CASE WHEN cp.permission_type IS NOT NULL THEN cp.permission_type 
                            ELSE 'NONE' END as user_permission
                FROM tb_knowledge_containers c
                LEFT JOIN tb_container_permissions cp ON c.container_id = cp.container_id 
                    AND cp.user_emp_no = :user_id AND cp.is_active = true
                WHERE c.container_id = :container_id AND c.is_active = true
                
                UNION ALL
                
                SELECT c.container_id, c.container_name, c.parent_container_id,
                       c.org_level, c.org_path, c.access_level, ct.depth + 1,
                       CASE WHEN cp.permission_type IS NOT NULL THEN cp.permission_type 
                            ELSE 'NONE' END as user_permission
                FROM tb_knowledge_containers c
                JOIN container_tree ct ON c.parent_container_id = ct.container_id
                LEFT JOIN tb_container_permissions cp ON c.container_id = cp.container_id 
                    AND cp.user_emp_no = :user_id AND cp.is_active = true
                WHERE c.is_active = true
            )
            SELECT * FROM container_tree ORDER BY depth, container_name
            """
            params = {"container_id": container_id, "user_id": user_id}
        else:
            # ì „ì²´ ì¡°ì§ êµ¬ì¡° (ì‚¬ìš©ì ì ‘ê·¼ ê°€ëŠ¥í•œ ì»¨í…Œì´ë„ˆë§Œ)
            if user_id and include_permissions:
                query = """
                SELECT c.container_id, c.container_name, c.parent_container_id,
                       c.org_level, c.org_path, c.document_count, c.total_knowledge_size,
                       c.access_level,
                       CASE WHEN cp.permission_type IS NOT NULL THEN cp.permission_type 
                            ELSE 'NONE' END as user_permission
                FROM tb_knowledge_containers c
                LEFT JOIN tb_container_permissions cp ON c.container_id = cp.container_id 
                    AND cp.user_emp_no = :user_id AND cp.is_active = true
                WHERE c.is_active = true 
                AND (c.access_level = 'public' OR cp.permission_type IS NOT NULL)
                ORDER BY c.org_path
                """
                params = {"user_id": user_id}
            else:
                query = """
                SELECT container_id, container_name, parent_container_id,
                       org_level, org_path, document_count, total_knowledge_size
                FROM tb_knowledge_containers 
                WHERE is_active = true 
                ORDER BY org_path
                """
                params = {}
        
        results = await self.db.fetch_all(query, params)
        tree_data = self.build_hierarchy_tree(results)
        
        # ê¶Œí•œ í†µê³„ ì¶”ê°€
        if user_id and include_permissions:
            tree_data["permission_summary"] = await self.get_user_permission_summary(user_id)
        
        return tree_data
            WITH RECURSIVE container_tree AS (
                SELECT container_id, container_name, parent_container_id, 
                       org_level, org_path, 0 as depth
                FROM tb_knowledge_containers 
                WHERE container_id = :container_id AND is_active = true
                
                UNION ALL
                
                SELECT c.container_id, c.container_name, c.parent_container_id,
                       c.org_level, c.org_path, ct.depth + 1
                FROM tb_knowledge_containers c
                JOIN container_tree ct ON c.parent_container_id = ct.container_id
                WHERE c.is_active = true
            )
            SELECT * FROM container_tree ORDER BY depth, container_name
            """
            params = {"container_id": container_id}
        else:
            # ì „ì²´ ì¡°ì§ êµ¬ì¡°
            query = """
            SELECT container_id, container_name, parent_container_id,
                   org_level, org_path, document_count, total_knowledge_size
            FROM tb_knowledge_containers 
            WHERE is_active = true 
            ORDER BY org_path
            """
            params = {}
        
        results = await self.db.fetch_all(query, params)
        return self.build_hierarchy_tree(results)
    
    def build_hierarchy_tree(self, flat_data: List[dict]) -> dict:
        """í‰ë©´ ë°ì´í„°ë¥¼ íŠ¸ë¦¬ êµ¬ì¡°ë¡œ ë³€í™˜"""
        node_map = {}
        root_nodes = []
        
        # ë…¸ë“œ ë§µ ìƒì„±
        for item in flat_data:
            node_map[item["container_id"]] = {
                **item,
                "children": []
            }
        
        # íŠ¸ë¦¬ êµ¬ì¡° êµ¬ì„±
        for item in flat_data:
            parent_id = item["parent_container_id"]
            if parent_id and parent_id in node_map:
                node_map[parent_id]["children"].append(node_map[item["container_id"]])
            else:
                root_nodes.append(node_map[item["container_id"]])
        
        return {
            "tree": root_nodes,
            "total_containers": len(flat_data),
            "max_depth": max([item["org_level"] for item in flat_data]) if flat_data else 0
        }
```

## 5. ê¶Œí•œ ê´€ë¦¬ ì‹œìŠ¤í…œ

### 5.1 ì¡°ì§ ê¸°ë°˜ ê¶Œí•œ ì²´ê³„

```sql
-- ì»¨í…Œì´ë„ˆ ê¶Œí•œ í…Œì´ë¸”
CREATE TABLE tb_container_permissions (
    permission_id SERIAL PRIMARY KEY,
    container_id INTEGER REFERENCES tb_knowledge_containers(container_id),
    user_emp_no VARCHAR(20) NOT NULL,
    
    -- ê¶Œí•œ ìœ í˜•
    permission_type VARCHAR(20) NOT NULL, -- read, write, admin, owner
    access_scope VARCHAR(20) DEFAULT 'container', -- container, descendants, ancestors
    
    -- ê¶Œí•œ ì¶œì²˜
    permission_source VARCHAR(30), -- direct, inherited, role_based, sap_sync
    source_container_id INTEGER, -- ìƒì†ë°›ì€ ì»¨í…Œì´ë„ˆ ID
    sap_role VARCHAR(50), -- SAP ì—­í• 
    
    -- ê¶Œí•œ ì œì•½
    restricted_categories INTEGER[], -- ì œí•œëœ ì¹´í…Œê³ ë¦¬
    time_restriction JSONB, -- ì‹œê°„ ì œí•œ {"start": "09:00", "end": "18:00"}
    ip_restriction INET[], -- IP ì œí•œ
    
    -- ê¶Œí•œ ë©”íƒ€ë°ì´í„°
    granted_by VARCHAR(20),
    granted_date TIMESTAMP DEFAULT now(),
    expires_date TIMESTAMP, -- ê¶Œí•œ ë§Œë£Œì¼
    is_active BOOLEAN DEFAULT true
);

-- ì—­í•  ê¸°ë°˜ ê¶Œí•œ í…œí”Œë¦¿
CREATE TABLE tb_role_permission_templates (
    template_id SERIAL PRIMARY KEY,
    role_name VARCHAR(50) NOT NULL,
    sap_role_code VARCHAR(50),
    
    -- ê¸°ë³¸ ê¶Œí•œ ì„¤ì •
    default_permission_type VARCHAR(20),
    default_access_scope VARCHAR(20),
    auto_assign_containers TEXT[], -- ìë™ í• ë‹¹ ì»¨í…Œì´ë„ˆ íŒ¨í„´
    
    -- ì œì•½ í…œí”Œë¦¿
    default_restrictions JSONB,
    
    is_active BOOLEAN DEFAULT true,
    created_date TIMESTAMP DEFAULT now()
);
```

### 5.2 ê¶Œí•œ í™•ì¸ ë° ìƒì†

```python
class ContainerPermissionManager:
    def __init__(self):
        self.db = get_database()
        self.cache = get_redis()
    
    async def check_user_permission(self, 
                                   user_emp_no: str,
                                   container_id: int,
                                   required_permission: str) -> bool:
        """ì‚¬ìš©ì ì»¨í…Œì´ë„ˆ ì ‘ê·¼ ê¶Œí•œ í™•ì¸"""
        
        # ìºì‹œ í™•ì¸
        cache_key = f"permission:{user_emp_no}:{container_id}:{required_permission}"
        cached_result = await self.cache.get(cache_key)
        if cached_result:
            return cached_result == "true"
        
        # ì§ì ‘ ê¶Œí•œ í™•ì¸
        direct_permission = await self.check_direct_permission(
            user_emp_no, container_id, required_permission
        )
        
        if direct_permission:
            await self.cache.setex(cache_key, 300, "true")
            return True
        
        # ìƒì† ê¶Œí•œ í™•ì¸
        inherited_permission = await self.check_inherited_permission(
            user_emp_no, container_id, required_permission
        )
        
        result = inherited_permission
        await self.cache.setex(cache_key, 300, "true" if result else "false")
        return result
    
    async def check_inherited_permission(self,
                                       user_emp_no: str,
                                       container_id: int,
                                       required_permission: str) -> bool:
        """ìƒìœ„ ì»¨í…Œì´ë„ˆë¡œë¶€í„° ê¶Œí•œ ìƒì† í™•ì¸"""
        
        # ìƒìœ„ ì»¨í…Œì´ë„ˆ ê²½ë¡œ ì¡°íšŒ
        ancestor_query = """
        WITH RECURSIVE ancestors AS (
            SELECT container_id, parent_container_id, 1 as level
            FROM tb_knowledge_containers 
            WHERE container_id = :container_id
            
            UNION ALL
            
            SELECT c.container_id, c.parent_container_id, a.level + 1
            FROM tb_knowledge_containers c
            JOIN ancestors a ON c.container_id = a.parent_container_id
            WHERE a.level < 10  -- ë¬´í•œë£¨í”„ ë°©ì§€
        )
        SELECT container_id FROM ancestors WHERE container_id != :container_id
        """
        
        ancestors = await self.db.fetch_all(ancestor_query, {"container_id": container_id})
        
        # ê° ìƒìœ„ ì»¨í…Œì´ë„ˆì—ì„œ ìƒì† ê°€ëŠ¥í•œ ê¶Œí•œ í™•ì¸
        for ancestor in ancestors:
            permission_query = """
            SELECT permission_type, access_scope 
            FROM tb_container_permissions 
            WHERE container_id = :ancestor_id 
              AND user_emp_no = :user_emp_no 
              AND is_active = true
              AND (expires_date IS NULL OR expires_date > now())
              AND access_scope IN ('descendants', 'ancestors')
            """
            
            permissions = await self.db.fetch_all(permission_query, {
                "ancestor_id": ancestor["container_id"],
                "user_emp_no": user_emp_no
            })
            
            for perm in permissions:
                if self.permission_includes(perm["permission_type"], required_permission):
                    return True
        
        return False
    
    def permission_includes(self, granted_permission: str, required_permission: str) -> bool:
        """ê¶Œí•œ í¬í•¨ ê´€ê³„ í™•ì¸"""
        permission_hierarchy = {
            "owner": ["admin", "write", "read"],
            "admin": ["write", "read"],
            "write": ["read"],
            "read": []
        }
        
        return required_permission in permission_hierarchy.get(granted_permission, [])
```

## 6. ì§€ì‹ ë¶„ë¥˜ ë° ìë™ ì¹´í…Œê³ ë¦¬í™”

### 6.1 ìë™ ì§€ì‹ ë¶„ë¥˜

```python
class KnowledgeClassifier:
    def __init__(self):
        self.bedrock_client = BedrockClient()
        self.db = get_database()
    
    async def auto_classify_document(self, 
                                   document_content: str,
                                   container_id: int,
                                   file_metadata: dict) -> dict:
        """ë¬¸ì„œ ìë™ ë¶„ë¥˜"""
        
        # 1. ì»¨í…Œì´ë„ˆì˜ ê¸°ë³¸ ì¹´í…Œê³ ë¦¬ ì¡°íšŒ
        container_categories = await self.get_container_categories(container_id)
        
        # 2. AI ê¸°ë°˜ ë¶„ë¥˜
        ai_classification = await self.classify_with_ai(
            document_content, container_categories
        )
        
        # 3. í‚¤ì›Œë“œ ê¸°ë°˜ ë¶„ë¥˜
        keyword_classification = self.classify_by_keywords(
            document_content, container_categories
        )
        
        # 4. íŒŒì¼ íŠ¹ì„± ê¸°ë°˜ ë¶„ë¥˜
        metadata_classification = self.classify_by_metadata(
            file_metadata, container_categories
        )
        
        # 5. ì¢…í•© ë¶„ë¥˜ ê²°ì •
        final_classification = self.combine_classifications([
            ai_classification,
            keyword_classification,
            metadata_classification
        ])
        
        return final_classification
    
    async def classify_with_ai(self, 
                             content: str,
                             available_categories: List[dict]) -> dict:
        """AI ê¸°ë°˜ ë¬¸ì„œ ë¶„ë¥˜"""
        
        category_descriptions = "\n".join([
            f"- {cat['category_name']}: {cat['description']}"
            for cat in available_categories
        ])
        
        prompt = f"""
        ë‹¤ìŒ ë¬¸ì„œ ë‚´ìš©ì„ ë¶„ì„í•˜ì—¬ ê°€ì¥ ì ì ˆí•œ ì¹´í…Œê³ ë¦¬ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.

        ë¬¸ì„œ ë‚´ìš©:
        {content[:2000]}...

        ì‚¬ìš© ê°€ëŠ¥í•œ ì¹´í…Œê³ ë¦¬:
        {category_descriptions}

        ë¶„ë¥˜ ê¸°ì¤€:
        1. ë¬¸ì„œì˜ ì£¼ìš” ë‚´ìš©ê³¼ ëª©ì 
        2. ì‚¬ìš© ëŒ€ìƒ ë° í™œìš©ë„
        3. ë¬¸ì„œì˜ í˜•ì‹ê³¼ êµ¬ì¡°
        4. ì—…ë¬´ í”„ë¡œì„¸ìŠ¤ì™€ì˜ ì—°ê´€ì„±

        ë¶„ë¥˜ ê²°ê³¼ë¥¼ JSON í˜•ì‹ìœ¼ë¡œ ì œê³µí•´ì£¼ì„¸ìš”:
        {{
            "primary_category": "ì¹´í…Œê³ ë¦¬ëª…",
            "confidence": 0.85,
            "secondary_categories": ["ë³´ì¡°ì¹´í…Œê³ ë¦¬1", "ë³´ì¡°ì¹´í…Œê³ ë¦¬2"],
            "reasoning": "ë¶„ë¥˜ ì´ìœ "
        }}
        """
        
        response = await self.bedrock_client.generate_text(prompt)
        
        try:
            classification = json.loads(response)
            return {
                "method": "ai",
                "classification": classification,
                "confidence": classification.get("confidence", 0.5)
            }
        except json.JSONDecodeError:
            return {
                "method": "ai",
                "classification": None,
                "confidence": 0.0
            }
```

### 6.2 ì§€ì‹ ì¹´í…Œê³ ë¦¬ ê´€ë¦¬

```python
class KnowledgeCategoryManager:
    def __init__(self):
        self.db = get_database()
    
    async def create_category_hierarchy(self, categories_data: List[dict]) -> dict:
        """ì¹´í…Œê³ ë¦¬ ê³„ì¸µ êµ¬ì¡° ìƒì„±"""
        
        created_categories = []
        
        # ë ˆë²¨ ìˆœì„œë¡œ ì •ë ¬í•˜ì—¬ ìƒì„±
        sorted_categories = sorted(categories_data, key=lambda x: x.get("level", 1))
        
        for category_data in sorted_categories:
            category_id = await self.create_category(category_data)
            created_categories.append(category_id)
        
        return {
            "created_count": len(created_categories),
            "category_ids": created_categories
        }
    
    async def get_category_suggestions(self, 
                                     container_id: int,
                                     document_content: str) -> List[dict]:
        """ì¹´í…Œê³ ë¦¬ ì¶”ì²œ"""
        
        # 1. ì»¨í…Œì´ë„ˆì˜ ê¸°ì¡´ ì¹´í…Œê³ ë¦¬ ë¶„ì„
        existing_categories = await self.get_container_category_distribution(container_id)
        
        # 2. ìœ ì‚¬ ë¬¸ì„œì˜ ì¹´í…Œê³ ë¦¬ ë¶„ì„
        similar_doc_categories = await self.get_similar_document_categories(
            document_content, container_id
        )
        
        # 3. AI ê¸°ë°˜ ìƒˆë¡œìš´ ì¹´í…Œê³ ë¦¬ ì œì•ˆ
        ai_suggestions = await self.suggest_new_categories(
            document_content, existing_categories
        )
        
        # 4. ì¢…í•© ì¶”ì²œ ë¦¬ìŠ¤íŠ¸ ìƒì„±
        suggestions = self.combine_category_suggestions([
            existing_categories,
            similar_doc_categories,
            ai_suggestions
        ])
        
        return suggestions
```

## 7. ì§€ì‹ ë§µ ì‹œê°í™”

### 7.1 ì¡°ì§ê°„ ì§€ì‹ ì—°ê´€ê´€ê³„ ë¶„ì„

```python
class KnowledgeMapAnalyzer:
    def __init__(self):
        self.db = get_database()
        self.graph_db = get_neo4j()  # ì„ íƒì  ê·¸ë˜í”„ DB
    
    async def analyze_knowledge_relationships(self, container_id: int = None) -> dict:
        """ì§€ì‹ ì—°ê´€ê´€ê³„ ë¶„ì„"""
        
        # 1. ë¬¸ì„œê°„ ìœ ì‚¬ë„ ê¸°ë°˜ ì—°ê´€ê´€ê³„
        document_relations = await self.analyze_document_similarity(container_id)
        
        # 2. í‚¤ì›Œë“œ ê¸°ë°˜ ì—°ê´€ê´€ê³„
        keyword_relations = await self.analyze_keyword_relationships(container_id)
        
        # 3. ì‚¬ìš©ì ì ‘ê·¼ íŒ¨í„´ ê¸°ë°˜ ì—°ê´€ê´€ê³„
        access_pattern_relations = await self.analyze_access_patterns(container_id)
        
        # 4. ì¡°ì§ê°„ ì§€ì‹ ê³µìœ  íŒ¨í„´
        org_sharing_patterns = await self.analyze_org_sharing_patterns(container_id)
        
        return {
            "document_relations": document_relations,
            "keyword_relations": keyword_relations,
            "access_patterns": access_pattern_relations,
            "org_sharing": org_sharing_patterns
        }
    
    async def build_knowledge_graph(self, container_id: int = None) -> dict:
        """ì§€ì‹ ê·¸ë˜í”„ êµ¬ì¶•"""
        
        # ë…¸ë“œ ìƒì„± (ì»¨í…Œì´ë„ˆ, ë¬¸ì„œ, ì¹´í…Œê³ ë¦¬, í‚¤ì›Œë“œ)
        nodes = await self.create_knowledge_nodes(container_id)
        
        # ì—£ì§€ ìƒì„± (ì—°ê´€ê´€ê³„)
        edges = await self.create_knowledge_edges(container_id)
        
        # ê·¸ë˜í”„ ë©”íŠ¸ë¦­ ê³„ì‚°
        metrics = self.calculate_graph_metrics(nodes, edges)
        
        return {
            "nodes": nodes,
            "edges": edges,
            "metrics": metrics,
            "visualization_data": self.prepare_visualization_data(nodes, edges)
        }
```

### 7.2 ì§€ì‹ íë¦„ ë¶„ì„

```sql
-- ì§€ì‹ ì ‘ê·¼ ë¡œê·¸ í…Œì´ë¸”
CREATE TABLE tb_knowledge_access_log (
    access_id SERIAL PRIMARY KEY,
    user_emp_no VARCHAR(20) NOT NULL,
    container_id INTEGER REFERENCES tb_knowledge_containers(container_id),
    document_id INTEGER REFERENCES tb_file_bss_info(FILE_BSS_INFO_SNO),
    
    -- ì ‘ê·¼ ì •ë³´
    access_type VARCHAR(20), -- view, download, search, share
    access_source VARCHAR(30), -- direct, search, recommendation, link
    session_id VARCHAR(100),
    
    -- ì»¨í…ìŠ¤íŠ¸ ì •ë³´
    search_query TEXT, -- ê²€ìƒ‰ì„ í†µí•œ ì ‘ê·¼ì¸ ê²½ìš°
    referrer_document_id INTEGER, -- ì°¸ì¡° ë¬¸ì„œ
    access_duration INTEGER, -- ì ‘ê·¼ ì‹œê°„ (ì´ˆ)
    
    -- ë©”íƒ€ë°ì´í„°
    ip_address INET,
    user_agent TEXT,
    access_timestamp TIMESTAMP DEFAULT now()
);

-- ì§€ì‹ ê³µìœ  ë¡œê·¸
CREATE TABLE tb_knowledge_sharing_log (
    sharing_id SERIAL PRIMARY KEY,
    sharer_emp_no VARCHAR(20) NOT NULL,
    recipient_emp_no VARCHAR(20),
    recipient_container_id INTEGER,
    document_id INTEGER REFERENCES tb_file_bss_info(FILE_BSS_INFO_SNO),
    
    sharing_type VARCHAR(20), -- direct, link, recommendation
    sharing_message TEXT,
    
    created_date TIMESTAMP DEFAULT now()
);
```

## 8. API ì„¤ê³„

### 8.1 ì»¨í…Œì´ë„ˆ ê´€ë¦¬ API

```python
@router.get("/containers/hierarchy")
async def get_container_hierarchy(
    container_id: int = None,
    include_stats: bool = False,
    user_emp_no: str = Depends(get_current_user)
):
    """ì»¨í…Œì´ë„ˆ ê³„ì¸µ êµ¬ì¡° ì¡°íšŒ"""
    
    # ì‚¬ìš©ì ì ‘ê·¼ ê¶Œí•œ í™•ì¸
    if container_id:
        has_permission = await permission_manager.check_user_permission(
            user_emp_no, container_id, "read"
        )
        if not has_permission:
            raise HTTPException(403, "ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤")
    
    # ê³„ì¸µ êµ¬ì¡° ì¡°íšŒ
    hierarchy = await hierarchy_manager.get_container_hierarchy(container_id)
    
    if include_stats:
        # í†µê³„ ì •ë³´ ì¶”ê°€
        hierarchy = await add_container_statistics(hierarchy, user_emp_no)
    
    return hierarchy

@router.post("/containers")
async def create_container(
    container_data: ContainerCreateRequest,
    user_emp_no: str = Depends(get_current_user)
):
    """ìƒˆ ì§€ì‹ ì»¨í…Œì´ë„ˆ ìƒì„±"""
    
    # ìƒìœ„ ì»¨í…Œì´ë„ˆ ê¶Œí•œ í™•ì¸
    if container_data.parent_container_id:
        has_permission = await permission_manager.check_user_permission(
            user_emp_no, container_data.parent_container_id, "admin"
        )
        if not has_permission:
            raise HTTPException(403, "ìƒìœ„ ì»¨í…Œì´ë„ˆ ê´€ë¦¬ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤")
    
    # ì»¨í…Œì´ë„ˆ ìƒì„±
    container_id = await container_manager.create_container(
        container_data.dict(), user_emp_no
    )
    
    # ìƒì„±ìì—ê²Œ owner ê¶Œí•œ ë¶€ì—¬
    await permission_manager.grant_permission(
        user_emp_no, container_id, "owner", "direct"
    )
    
    return {"container_id": container_id, "status": "created"}
```

### 8.2 ì§€ì‹ ë¶„ë¥˜ API

```python
@router.post("/containers/{container_id}/classify-document")
async def classify_document(
    container_id: int,
    classification_request: DocumentClassificationRequest,
    user_emp_no: str = Depends(get_current_user)
):
    """ë¬¸ì„œ ìë™ ë¶„ë¥˜"""
    
    # ê¶Œí•œ í™•ì¸
    has_permission = await permission_manager.check_user_permission(
        user_emp_no, container_id, "write"
    )
    if not has_permission:
        raise HTTPException(403, "ë¶„ë¥˜ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤")
    
    # ìë™ ë¶„ë¥˜ ìˆ˜í–‰
    classification = await classifier.auto_classify_document(
        classification_request.content,
        container_id,
        classification_request.metadata
    )
    
    return classification

@router.get("/containers/{container_id}/knowledge-map")
async def get_knowledge_map(
    container_id: int,
    depth: int = 2,
    include_related: bool = True,
    user_emp_no: str = Depends(get_current_user)
):
    """ì§€ì‹ ë§µ ì¡°íšŒ"""
    
    # ê¶Œí•œ í™•ì¸
    has_permission = await permission_manager.check_user_permission(
        user_emp_no, container_id, "read"
    )
    if not has_permission:
        raise HTTPException(403, "ì¡°íšŒ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤")
    
    # ì§€ì‹ ë§µ ìƒì„±
    knowledge_map = await map_analyzer.build_knowledge_graph(
        container_id, depth, include_related
    )
    
    return knowledge_map
```

## 9. ì„±ëŠ¥ ìµœì í™”

### 9.1 ê³„ì¸µ êµ¬ì¡° ìµœì í™”

- **Materialized Path**: ì¡°ì§ ê²½ë¡œ ì €ì¥ìœ¼ë¡œ ë¹ ë¥¸ ê³„ì¸µ ì¡°íšŒ
- **ì¸ë±ìŠ¤ ìµœì í™”**: íŠ¸ë¦¬ êµ¬ì¡° ì „ìš© ì¸ë±ìŠ¤
- **ìºì‹± ì „ëµ**: ìì£¼ ì¡°íšŒë˜ëŠ” ê³„ì¸µ êµ¬ì¡° ìºì‹±
- **ì§€ì—° ë¡œë”©**: í•„ìš”í•œ ë¶€ë¶„ë§Œ ì ì§„ì  ë¡œë”©

### 9.2 ê¶Œí•œ í™•ì¸ ìµœì í™”

- **ê¶Œí•œ ìºì‹±**: Redis ê¸°ë°˜ ê¶Œí•œ ê²°ê³¼ ìºì‹±
- **ë°°ì¹˜ ê¶Œí•œ í™•ì¸**: ì—¬ëŸ¬ ë¦¬ì†ŒìŠ¤ ê¶Œí•œ ì¼ê´„ í™•ì¸
- **ê¶Œí•œ ìƒì† ìµœì í™”**: íš¨ìœ¨ì ì¸ ìƒì† ê´€ê³„ ê³„ì‚°

## 10. ëª¨ë‹ˆí„°ë§ ë° ë¶„ì„

### 10.1 ì»¨í…Œì´ë„ˆ ì‚¬ìš© ë¶„ì„

- **ë¬¸ì„œ ì—…ë¡œë“œ í†µê³„**: ì»¨í…Œì´ë„ˆë³„ ë¬¸ì„œ ì¦ê°€ ì¶”ì´
- **ì‚¬ìš©ì ì ‘ê·¼ íŒ¨í„´**: ì¡°ì§ë³„ ì§€ì‹ í™œìš©ë„
- **ì§€ì‹ í’ˆì§ˆ ì§€í‘œ**: ë¬¸ì„œ í’ˆì§ˆ ë° í™œìš©ë„
- **í˜‘ì—… íŒ¨í„´**: ì¡°ì§ê°„ ì§€ì‹ ê³µìœ  ë¶„ì„

### 10.2 ì¡°ì§ ì§€ì‹ ì„±ìˆ™ë„ í‰ê°€

```python
class OrganizationKnowledgeMaturity:
    def calculate_maturity_score(self, container_id: int) -> dict:
        """ì¡°ì§ ì§€ì‹ ì„±ìˆ™ë„ í‰ê°€"""
        
        metrics = {
            "knowledge_coverage": self.calculate_coverage_score(container_id),
            "knowledge_quality": self.calculate_quality_score(container_id),
            "knowledge_accessibility": self.calculate_accessibility_score(container_id),
            "knowledge_utilization": self.calculate_utilization_score(container_id),
            "knowledge_sharing": self.calculate_sharing_score(container_id)
        }
        
        overall_maturity = sum(metrics.values()) / len(metrics)
        
        return {
            "overall_maturity": overall_maturity,
            "maturity_level": self.get_maturity_level(overall_maturity),
            "metrics": metrics,
            "recommendations": self.generate_recommendations(metrics)
        }
```

## 11. ğŸ”§ ì‹œìŠ¤í…œ ê´€ë¦¬ì ì „ìš© ê¸°ëŠ¥

### 11.1 SAP ì—°ë™ ì‹œìŠ¤í…œ ê´€ë¦¬

#### 11.1.1 SAP ì¡°ì§ë„ ë™ê¸°í™” ëª¨ë‹ˆí„°ë§

```python
# /admin/system/sap-integration/
class SAPIntegrationMonitor:
    async def get_sync_status(self):
        """SAP ë™ê¸°í™” ìƒíƒœ ëª¨ë‹ˆí„°ë§"""
        return {
            "connection_status": {
                "sap_rfc_status": "connected",
                "last_sync": "2024-03-20 09:30:00",
                "sync_frequency": "daily_06:00",
                "next_sync": "2024-03-21 06:00:00"
            },
            "sync_metrics": {
                "total_org_units": 156,
                "added_units": 3,
                "modified_units": 12,
                "removed_units": 1,
                "error_count": 0
            },
            "performance": {
                "sync_duration": "45 seconds",
                "avg_response_time": "120ms",
                "memory_usage": "245MB",
                "cpu_usage": "12%"
            }
        }
        
    async def force_manual_sync(self, sync_type: str = "incremental"):
        """ìˆ˜ë™ ë™ê¸°í™” ì‹¤í–‰"""
        if sync_type == "full":
            # ì „ì²´ ì¡°ì§ë„ ì¬ë™ê¸°í™”
            task = await self.task_queue.enqueue("full_org_sync", priority="high")
        else:
            # ì¦ë¶„ ë™ê¸°í™”
            task = await self.task_queue.enqueue("incremental_org_sync")
            
        return {
            "task_id": task.id,
            "estimated_time": "2-5ë¶„",
            "status": "initiated"
        }
```

#### 11.1.2 ì¡°ì§ êµ¬ì¡° ë³€ê²½ ê°ì§€ ë° ì²˜ë¦¬

```python
class OrganizationChangeDetector:
    async def detect_org_changes(self):
        """ì¡°ì§ ë³€ê²½ì‚¬í•­ ê°ì§€"""
        return {
            "pending_changes": [
                {
                    "change_type": "department_creation",
                    "details": {
                        "new_dept": "ë””ì§€í„¸í˜ì‹ íŒ€",
                        "parent_dept": "ê¸°íšë³¸ë¶€",
                        "effective_date": "2024-04-01"
                    },
                    "impact_analysis": {
                        "affected_containers": 0,
                        "affected_permissions": 0,
                        "migration_required": False
                    }
                },
                {
                    "change_type": "department_merge",
                    "details": {
                        "source_depts": ["ITê¸°íšíŒ€", "ì‹œìŠ¤í…œìš´ì˜íŒ€"],
                        "target_dept": "ITí†µí•©íŒ€",
                        "effective_date": "2024-04-15"
                    },
                    "impact_analysis": {
                        "affected_containers": 2,
                        "affected_permissions": 45,
                        "migration_required": True
                    }
                }
            ],
            "auto_processing": {
                "enabled": True,
                "approval_required": ["merge", "deletion"],
                "auto_approve": ["creation", "rename"]
            }
        }
        
    async def process_org_change(self, change_id: str, action: str):
        """ì¡°ì§ ë³€ê²½ì‚¬í•­ ì²˜ë¦¬"""
        # ì»¨í…Œì´ë„ˆ ë³‘í•©/ì´ë™/ìƒì„± ì²˜ë¦¬
        # ê¶Œí•œ ì¬í• ë‹¹
        # ì§€ì‹ ë§ˆì´ê·¸ë ˆì´ì…˜
        pass
```

### 11.2 ì»¨í…Œì´ë„ˆ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜ ê´€ë¦¬

#### 11.2.1 ì»¨í…Œì´ë„ˆ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

```python
class ContainerPerformanceMonitor:
    async def get_container_metrics(self):
        """ì»¨í…Œì´ë„ˆë³„ ì„±ëŠ¥ ë©”íŠ¸ë¦­"""
        return {
            "container_stats": [
                {
                    "container_id": "C001",
                    "name": "ê¸°íšë³¸ë¶€",
                    "document_count": 1245,
                    "storage_size": "2.3GB",
                    "access_frequency": 450,
                    "query_performance": "avg 0.8s",
                    "cache_hit_rate": "87%"
                }
            ],
            "system_wide_metrics": {
                "total_containers": 156,
                "active_containers": 134,
                "total_storage": "45.6GB",
                "avg_response_time": "1.2s",
                "peak_concurrent_users": 89
            },
            "performance_alerts": [
                {
                    "container": "ì¸ì‚¬íŒ€",
                    "issue": "ë†’ì€ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰",
                    "severity": "warning",
                    "recommendation": "ì¸ë±ìŠ¤ ìµœì í™” í•„ìš”"
                }
            ]
        }
```

#### 11.2.2 ë°ì´í„°ë² ì´ìŠ¤ íŒŒí‹°ì…”ë‹ ê´€ë¦¬

```python
class ContainerPartitionManager:
    async def analyze_partitioning_strategy(self):
        """íŒŒí‹°ì…”ë‹ ì „ëµ ë¶„ì„"""
        return {
            "current_partitions": {
                "tb_knowledge_containers": "by_org_level",
                "tb_container_documents": "by_container_id", 
                "tb_container_permissions": "by_user_range"
            },
            "partition_performance": {
                "query_improvement": "+45%",
                "maintenance_overhead": "12%",
                "storage_efficiency": "+23%"
            },
            "recommendations": [
                {
                    "action": "add_partition",
                    "table": "tb_container_analytics",
                    "strategy": "by_date_range",
                    "expected_benefit": "25% query performance improvement"
                }
            ]
        }
```

### 11.3 ê¶Œí•œ ì‹œìŠ¤í…œ ê°ì‚¬ ë° ë³´ì•ˆ

#### 11.3.1 ê¶Œí•œ ê°ì‚¬ ì‹œìŠ¤í…œ

```python
class PermissionAuditSystem:
    async def conduct_permission_audit(self):
        """ê¶Œí•œ ê°ì‚¬ ì‹¤í–‰"""
        return {
            "audit_summary": {
                "total_permissions": 2456,
                "active_permissions": 2234,
                "inactive_permissions": 222,
                "suspicious_activities": 3
            },
            "findings": [
                {
                    "type": "privilege_escalation",
                    "user": "emp_1234",
                    "description": "ì‚¬ìš©ìê°€ ë³¸ì¸ ë¶€ì„œ ì™¸ ì»¨í…Œì´ë„ˆì— ì ‘ê·¼",
                    "risk_level": "medium",
                    "investigation_required": True
                },
                {
                    "type": "orphaned_permission",
                    "count": 15,
                    "description": "í‡´ì‚¬ì ê³„ì •ì˜ ì”ì—¬ ê¶Œí•œ",
                    "risk_level": "high",
                    "auto_cleanup": True
                }
            ],
            "compliance_status": {
                "gdpr_compliant": True,
                "internal_policy_compliant": True,
                "security_score": 94
            }
        }
        
    async def generate_audit_report(self, report_type: str = "monthly"):
        """ê°ì‚¬ ë³´ê³ ì„œ ìƒì„±"""
        return {
            "report_id": "AUDIT_2024_03",
            "period": "2024-03-01 to 2024-03-31",
            "summary": "ê¶Œí•œ ì‹œìŠ¤í…œ ì •ìƒ ìš´ì˜ ì¤‘",
            "recommendations": [
                "ì •ê¸°ì ì¸ ê¶Œí•œ ì •ë¦¬ í•„ìš”",
                "ë‹¤ì¤‘ ì¸ì¦ ë„ì… ê²€í† "
            ]
        }
```

## 12. ğŸ“š ì§€ì‹ ê´€ë¦¬ì ì „ìš© ê¸°ëŠ¥

### 12.1 ì»¨í…Œì´ë„ˆ ìš´ì˜ ê´€ë¦¬

#### 12.1.1 ì»¨í…Œì´ë„ˆ ìƒì„± ë° êµ¬ì¡° ê´€ë¦¬

```python
# /knowledge-admin/containers/management
class ContainerManagementSystem:
    async def create_container(self, container_data: dict):
        """ìƒˆ ì§€ì‹ ì»¨í…Œì´ë„ˆ ìƒì„±"""
        return {
            "container_creation": {
                "name": container_data["name"],
                "parent_container": container_data.get("parent_id"),
                "org_code": container_data["sap_org_code"],
                "description": container_data["description"],
                "category": container_data.get("category", "general")
            },
            "initial_setup": {
                "default_permissions": "inherited_from_parent",
                "knowledge_templates": ["ê¸°ë³¸ë¬¸ì„œì–‘ì‹", "ì—…ë¬´ë§¤ë‰´ì–¼ì–‘ì‹"],
                "auto_classification": True,
                "notification_settings": "default"
            },
            "container_id": "C156",
            "status": "created",
            "next_steps": [
                "ê¶Œí•œ ì„¤ì • ê²€í† ",
                "ì´ˆê¸° ë¬¸ì„œ ì—…ë¡œë“œ",
                "ë‹´ë‹¹ì ì§€ì •"
            ]
        }
        
    async def get_container_hierarchy(self, root_container: str = None):
        """ì»¨í…Œì´ë„ˆ ê³„ì¸µ êµ¬ì¡° ì¡°íšŒ"""
        return {
            "hierarchy": {
                "ê¸°ì—…": {
                    "container_id": "C001",
                    "children": {
                        "ê¸°íšë³¸ë¶€": {
                            "container_id": "C010",
                            "children": {
                                "ì „ëµê¸°íšíŒ€": {"container_id": "C011"},
                                "ì‚¬ì—…ê¸°íšíŒ€": {"container_id": "C012"}
                            }
                        },
                        "ì¸ì‚¬ë³¸ë¶€": {
                            "container_id": "C020",
                            "children": {
                                "ì¸ì‚¬íŒ€": {"container_id": "C021"},
                                "êµìœ¡íŒ€": {"container_id": "C022"}
                            }
                        }
                    }
                }
            },
            "statistics": {
                "total_containers": 156,
                "active_containers": 134,
                "empty_containers": 12,
                "max_depth": 5
            }
        }
```

#### 12.1.2 ì»¨í…Œì´ë„ˆë³„ ì§€ì‹ ë¶„ì„

```python
class ContainerKnowledgeAnalyzer:
    async def analyze_container_knowledge(self, container_id: str):
        """ì»¨í…Œì´ë„ˆ ì§€ì‹ í˜„í™© ë¶„ì„"""
        return {
            "knowledge_overview": {
                "total_documents": 234,
                "document_types": {
                    "ì—…ë¬´ë§¤ë‰´ì–¼": 45,
                    "ì •ì±…ë¬¸ì„œ": 32,
                    "í”„ë¡œì íŠ¸ìë£Œ": 89,
                    "ê¸°íƒ€": 68
                },
                "knowledge_quality": {
                    "avg_quality_score": 4.2,
                    "outdated_documents": 12,
                    "high_quality_docs": 189
                }
            },
            "usage_patterns": {
                "most_accessed": [
                    {"title": "ì‹ ì…ì‚¬ì› êµìœ¡ ë§¤ë‰´ì–¼", "access_count": 156},
                    {"title": "í”„ë¡œì íŠ¸ ê´€ë¦¬ ê°€ì´ë“œ", "access_count": 134}
                ],
                "search_keywords": ["êµìœ¡", "ë§¤ë‰´ì–¼", "í”„ë¡œì„¸ìŠ¤", "ê°€ì´ë“œ"],
                "user_engagement": {
                    "active_users": 23,
                    "avg_session_time": "8.5ë¶„",
                    "return_rate": "78%"
                }
            },
            "knowledge_gaps": [
                {"area": "ë¦¬ëª¨íŠ¸ì›Œí¬ ì •ì±…", "urgency": "high"},
                {"area": "ì‹ ê¸°ìˆ  ë„ì… í”„ë¡œì„¸ìŠ¤", "urgency": "medium"}
            ]
        }
```

### 12.2 ê¶Œí•œ ë° ì ‘ê·¼ ê´€ë¦¬

#### 12.2.1 ì„¸ë¶„í™”ëœ ê¶Œí•œ ê´€ë¦¬

```python
class DetailedPermissionManager:
    async def manage_container_permissions(self, container_id: str):
        """ì»¨í…Œì´ë„ˆ ê¶Œí•œ ìƒì„¸ ê´€ë¦¬"""
        return {
            "permission_matrix": {
                "roles": {
                    "container_admin": {
                        "permissions": ["read", "write", "delete", "manage_users"],
                        "users": ["emp_001", "emp_045"]
                    },
                    "content_manager": {
                        "permissions": ["read", "write", "approve"],
                        "users": ["emp_012", "emp_078", "emp_123"]
                    },
                    "contributor": {
                        "permissions": ["read", "write"],
                        "users": ["emp_234", "emp_345", "emp_456"]
                    },
                    "viewer": {
                        "permissions": ["read"],
                        "users": ["emp_567", "emp_678"]
                    }
                }
            },
            "inherited_permissions": {
                "from_parent": ["read_only_shared_docs"],
                "to_children": ["basic_read_access"]
            },
            "special_permissions": [
                {
                    "user": "emp_999",
                    "permission": "external_sharing",
                    "expiry": "2024-06-30",
                    "reason": "í”„ë¡œì íŠ¸ í˜‘ì—…"
                }
            ]
        }
        
    async def bulk_permission_update(self, updates: List[dict]):
        """ëŒ€ëŸ‰ ê¶Œí•œ ì—…ë°ì´íŠ¸"""
        results = []
        for update in updates:
            try:
                await self.update_user_permission(
                    container_id=update["container_id"],
                    user_id=update["user_id"],
                    permissions=update["permissions"]
                )
                results.append({"user_id": update["user_id"], "status": "success"})
            except Exception as e:
                results.append({"user_id": update["user_id"], "status": "failed", "error": str(e)})
        
        return {"updated": len([r for r in results if r["status"] == "success"]), "results": results}
```

### 12.3 ì‚¬ìš©ì ì§€ì› ë° êµìœ¡

#### 12.3.1 ì»¨í…Œì´ë„ˆë³„ ì‚¬ìš©ì ì§€ì›

```python
class ContainerUserSupport:
    async def get_user_support_dashboard(self, container_id: str):
        """ì»¨í…Œì´ë„ˆë³„ ì‚¬ìš©ì ì§€ì› í˜„í™©"""
        return {
            "support_requests": {
                "open_tickets": 5,
                "resolved_today": 8,
                "avg_resolution_time": "3.2ì‹œê°„",
                "user_satisfaction": 4.5
            },
            "common_issues": [
                {"issue": "ê¶Œí•œ ìš”ì²­", "count": 12, "category": "access"},
                {"issue": "ë¬¸ì„œ ì—…ë¡œë“œ ì‹¤íŒ¨", "count": 8, "category": "technical"},
                {"issue": "ê²€ìƒ‰ ê²°ê³¼ ë¶€ì •í™•", "count": 6, "category": "content"}
            ],
            "training_needs": {
                "identified_gaps": ["ê³ ê¸‰ ê²€ìƒ‰ ì‚¬ìš©ë²•", "ë¬¸ì„œ íƒœê¹… ë°©ë²•"],
                "training_completion_rate": "67%",
                "next_training_session": "2024-03-25 14:00"
            }
        }
        
    async def create_user_guide(self, container_id: str, guide_type: str):
        """ì‚¬ìš©ì ê°€ì´ë“œ ìƒì„±"""
        if guide_type == "quick_start":
            return {
                "guide_id": "QG_001",
                "title": f"{await self.get_container_name(container_id)} ë¹ ë¥¸ ì‹œì‘ ê°€ì´ë“œ",
                "sections": [
                    "ì»¨í…Œì´ë„ˆ ì ‘ê·¼ ë°©ë²•",
                    "ë¬¸ì„œ ê²€ìƒ‰ ë° ë‹¤ìš´ë¡œë“œ",
                    "ìƒˆ ë¬¸ì„œ ì—…ë¡œë“œ",
                    "í˜‘ì—… ê¸°ëŠ¥ ì‚¬ìš©ë²•"
                ],
                "estimated_reading_time": "10ë¶„",
                "target_audience": "ì‹ ê·œ ì‚¬ìš©ì"
            }
```

### 12.4 ì§€ì‹ í’ˆì§ˆ ë° ìƒì• ì£¼ê¸° ê´€ë¦¬

#### 12.4.1 ì§€ì‹ ìƒì• ì£¼ê¸° ê´€ë¦¬

```python
class KnowledgeLifecycleManager:
    async def manage_document_lifecycle(self, container_id: str):
        """ë¬¸ì„œ ìƒì• ì£¼ê¸° ê´€ë¦¬"""
        return {
            "lifecycle_status": {
                "active_documents": 189,
                "review_required": 23,
                "outdated_documents": 12,
                "archived_documents": 45
            },
            "upcoming_reviews": [
                {
                    "document": "ì¸ì‚¬ ê·œì • v2.3",
                    "review_due": "2024-04-01",
                    "reviewer": "ì¸ì‚¬íŒ€ì¥",
                    "priority": "high"
                }
            ],
            "archival_candidates": [
                {
                    "document": "2022ë…„ í”„ë¡œì íŠ¸ ê²°ê³¼ë³´ê³ ì„œ",
                    "last_accessed": "2023-08-15",
                    "reason": "1ë…„ ì´ìƒ ë¯¸ì ‘ê·¼",
                    "archival_recommended": True
                }
            ],
            "retention_policies": {
                "ì¸ì‚¬ë¬¸ì„œ": "7ë…„ ë³´ê´€",
                "ì¬ë¬´ë¬¸ì„œ": "5ë…„ ë³´ê´€",
                "ì¼ë°˜ë¬¸ì„œ": "3ë…„ ë³´ê´€ í›„ ê²€í† "
            }
        }
```

## 13. ê¶Œí•œ ê¸°ë°˜ API ì—”ë“œí¬ì¸íŠ¸

### 13.1 ì»¨í…Œì´ë„ˆ ê´€ë¦¬ API

```python
@router.get("/containers/hierarchy")
async def get_container_hierarchy(
    container_id: Optional[int] = None,
    include_permissions: bool = True,
    current_user: User = Depends(get_current_user)
):
    """ì‚¬ìš©ì ê¶Œí•œ ê¸°ë°˜ ì»¨í…Œì´ë„ˆ ê³„ì¸µ êµ¬ì¡° ì¡°íšŒ"""
    try:
        # 1. ì‚¬ìš©ì ì¸ì¦ í™•ì¸
        if not current_user:
            raise HTTPException(401, "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤")
        
        # 2. íŠ¹ì • ì»¨í…Œì´ë„ˆ ì ‘ê·¼ ê¶Œí•œ í™•ì¸
        if container_id:
            has_access = await permission_service.check_container_access(
                current_user.emp_no, container_id
            )
            if not has_access:
                raise HTTPException(403, "í•´ë‹¹ ì»¨í…Œì´ë„ˆì— ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤")
        
        # 3. ê¶Œí•œ ê¸°ë°˜ ê³„ì¸µ êµ¬ì¡° ì¡°íšŒ
        hierarchy = await hierarchy_manager.get_container_hierarchy(
            container_id=container_id,
            user_id=current_user.emp_no,
            include_permissions=include_permissions
        )
        
        # 4. ì ‘ê·¼ ë¡œê·¸ ê¸°ë¡
        await audit_service.log_container_access(
            user_id=current_user.emp_no,
            container_id=container_id,
            action="hierarchy_view",
            metadata={"include_permissions": include_permissions}
        )
        
        return hierarchy
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"ì»¨í…Œì´ë„ˆ ê³„ì¸µ ì¡°íšŒ ì‹¤íŒ¨: {e}")
        raise HTTPException(500, f"ì¡°íšŒ ì‹¤íŒ¨: {str(e)}")

@router.post("/containers")
async def create_container(
    container_data: ContainerCreateRequest,
    current_user: User = Depends(get_current_user)
):
    """ê¶Œí•œ ê¸°ë°˜ ì»¨í…Œì´ë„ˆ ìƒì„±"""
    try:
        # 1. ì»¨í…Œì´ë„ˆ ìƒì„± ê¶Œí•œ í™•ì¸
        if current_user.role not in ['ADMIN', 'MANAGER']:
            raise HTTPException(403, "ì»¨í…Œì´ë„ˆ ìƒì„± ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤")
        
        # 2. ìƒìœ„ ì»¨í…Œì´ë„ˆì— ëŒ€í•œ ê´€ë¦¬ ê¶Œí•œ í™•ì¸
        if container_data.parent_container_id:
            has_admin_permission = await permission_service.check_container_permission(
                current_user.emp_no, container_data.parent_container_id, "ADMIN"
            )
            if not has_admin_permission:
                raise HTTPException(403, "ìƒìœ„ ì»¨í…Œì´ë„ˆì— ëŒ€í•œ ê´€ë¦¬ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤")
        
        # 3. ì»¨í…Œì´ë„ˆ ìƒì„±
        container_id = await container_manager.create_container(
            container_data.dict(),
            created_by=current_user.emp_no
        )
        
        # 4. ìƒì„±ìì—ê²Œ OWNER ê¶Œí•œ ë¶€ì—¬
        await permission_service.grant_container_permission(
            container_id=container_id,
            user_id=current_user.emp_no,
            permission_type="OWNER",
            granted_by=current_user.emp_no
        )
        
        # 5. ê¸°ë³¸ ê¶Œí•œ ì„¤ì • ì ìš©
        await permission_service.apply_default_permissions(
            container_id, container_data.default_permission_settings
        )
        
        # 6. ìƒì„± ë¡œê·¸ ê¸°ë¡
        await audit_service.log_container_management(
            user_id=current_user.emp_no,
            action="container_created",
            container_id=container_id,
            details=container_data.dict()
        )
        
        return {
            "container_id": container_id,
            "status": "created",
            "permissions_assigned": True,
            "next_steps": [
                "ì´ˆê¸° ë¬¸ì„œ ì—…ë¡œë“œ",
                "ì‚¬ìš©ì ê¶Œí•œ ì„¤ì • ê²€í† ",
                "ì¹´í…Œê³ ë¦¬ ì„¤ì •"
            ]
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"ì»¨í…Œì´ë„ˆ ìƒì„± ì‹¤íŒ¨: {e}")
        raise HTTPException(500, f"ìƒì„± ì‹¤íŒ¨: {str(e)}")

@router.get("/containers/{container_id}/permissions")
async def get_container_permissions(
    container_id: int,
    current_user: User = Depends(get_current_user)
):
    """ì»¨í…Œì´ë„ˆ ê¶Œí•œ ì¡°íšŒ"""
    try:
        # 1. ê¶Œí•œ ì¡°íšŒ ê¶Œí•œ í™•ì¸ (ADMIN ë˜ëŠ” MANAGERë§Œ ê°€ëŠ¥)
        has_admin_permission = await permission_service.check_container_permission(
            current_user.emp_no, container_id, "ADMIN"
        )
        if not has_admin_permission:
            raise HTTPException(403, "ê¶Œí•œ ì¡°íšŒ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤")
        
        # 2. ì»¨í…Œì´ë„ˆ ê¶Œí•œ ëª©ë¡ ì¡°íšŒ
        permissions = await permission_service.get_container_permissions(container_id)
        
        # 3. ê¶Œí•œ ìƒì† ê´€ê³„ ì¡°íšŒ
        inheritance_info = await permission_service.get_permission_inheritance(container_id)
        
        # 4. ê¶Œí•œ ìš”ì²­ ëŒ€ê¸° ëª©ë¡ ì¡°íšŒ
        pending_requests = await permission_service.get_pending_permission_requests(container_id)
        
        return {
            "container_id": container_id,
            "direct_permissions": permissions,
            "inheritance_info": inheritance_info,
            "pending_requests": pending_requests,
            "permission_summary": {
                "total_users": len(permissions),
                "admin_count": len([p for p in permissions if p["permission_type"] == "ADMIN"]),
                "manager_count": len([p for p in permissions if p["permission_type"] == "MANAGER"]),
                "editor_count": len([p for p in permissions if p["permission_type"] == "EDITOR"]),
                "viewer_count": len([p for p in permissions if p["permission_type"] == "VIEWER"])
            }
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"ê¶Œí•œ ì¡°íšŒ ì‹¤íŒ¨: {e}")
        raise HTTPException(500, f"ì¡°íšŒ ì‹¤íŒ¨: {str(e)}")

@router.post("/containers/{container_id}/permissions/request")
async def request_container_permission(
    container_id: int,
    request_data: PermissionRequestData,
    current_user: User = Depends(get_current_user)
):
    """ì»¨í…Œì´ë„ˆ ì ‘ê·¼ ê¶Œí•œ ìš”ì²­"""
    try:
        # 1. ê¸°ì¡´ ê¶Œí•œ í™•ì¸
        existing_permission = await permission_service.get_user_container_permission(
            current_user.emp_no, container_id
        )
        
        if existing_permission and existing_permission["permission_type"] in ["ADMIN", "MANAGER"]:
            return {"message": "ì´ë¯¸ ì¶©ë¶„í•œ ê¶Œí•œì„ ë³´ìœ í•˜ê³  ìˆìŠµë‹ˆë‹¤"}
        
        # 2. ì¤‘ë³µ ìš”ì²­ í™•ì¸
        existing_request = await permission_service.get_pending_user_request(
            current_user.emp_no, container_id
        )
        
        if existing_request:
            return {"message": "ì´ë¯¸ ê¶Œí•œ ìš”ì²­ì´ ì²˜ë¦¬ ëŒ€ê¸° ì¤‘ì…ë‹ˆë‹¤", "request_id": existing_request["request_id"]}
        
        # 3. ê¶Œí•œ ìš”ì²­ ìƒì„±
        request_id = await permission_service.create_permission_request(
            container_id=container_id,
            requester_id=current_user.emp_no,
            requested_permission=request_data.permission_type,
            justification=request_data.justification,
            request_metadata={
                "user_department": current_user.department,
                "user_position": current_user.position,
                "request_source": "web_interface"
            }
        )
        
        # 4. ìŠ¹ì¸ìì—ê²Œ ì•Œë¦¼ ë°œì†¡
        await notification_service.notify_permission_request(
            request_id=request_id,
            container_id=container_id,
            requester=current_user.emp_no
        )
        
        # 5. ìš”ì²­ ë¡œê·¸ ê¸°ë¡
        await audit_service.log_permission_activity(
            user_id=current_user.emp_no,
            action="permission_requested",
            container_id=container_id,
            details={
                "request_id": request_id,
                "requested_permission": request_data.permission_type,
                "justification": request_data.justification
            }
        )
        
        return {
            "request_id": request_id,
            "status": "submitted",
            "estimated_processing_time": "1-3 ì˜ì—…ì¼",
            "approvers": await permission_service.get_container_approvers(container_id)
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"ê¶Œí•œ ìš”ì²­ ì‹¤íŒ¨: {e}")
        raise HTTPException(500, f"ìš”ì²­ ì‹¤íŒ¨: {str(e)}")
```

### 13.2 ê¶Œí•œ ê´€ë¦¬ API

```python
@router.put("/containers/{container_id}/permissions/{user_id}")
async def update_user_permission(
    container_id: int,
    user_id: str,
    permission_data: PermissionUpdateRequest,
    current_user: User = Depends(get_current_user)
):
    """ì‚¬ìš©ì ê¶Œí•œ ì—…ë°ì´íŠ¸"""
    try:
        # 1. ê¶Œí•œ ë³€ê²½ ê¶Œí•œ í™•ì¸
        has_admin_permission = await permission_service.check_container_permission(
            current_user.emp_no, container_id, "ADMIN"
        )
        if not has_admin_permission:
            raise HTTPException(403, "ê¶Œí•œ ë³€ê²½ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤")
        
        # 2. ìì‹ ì˜ ê¶Œí•œì€ ë³€ê²½í•  ìˆ˜ ì—†ìŒ
        if user_id == current_user.emp_no:
            raise HTTPException(400, "ìì‹ ì˜ ê¶Œí•œì€ ë³€ê²½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
        
        # 3. ê¶Œí•œ ì—…ë°ì´íŠ¸
        result = await permission_service.update_user_permission(
            container_id=container_id,
            user_id=user_id,
            new_permission=permission_data.permission_type,
            expires_date=permission_data.expires_date,
            updated_by=current_user.emp_no,
            reason=permission_data.reason
        )
        
        # 4. ë³€ê²½ ì•Œë¦¼ ë°œì†¡
        await notification_service.notify_permission_change(
            user_id=user_id,
            container_id=container_id,
            new_permission=permission_data.permission_type,
            changed_by=current_user.emp_no
        )
        
        # 5. ë³€ê²½ ë¡œê·¸ ê¸°ë¡
        await audit_service.log_permission_activity(
            user_id=current_user.emp_no,
            action="permission_updated",
            container_id=container_id,
            target_user=user_id,
            details={
                "old_permission": result["old_permission"],
                "new_permission": permission_data.permission_type,
                "reason": permission_data.reason
            }
        )
        
        return {
            "status": "updated",
            "old_permission": result["old_permission"],
            "new_permission": permission_data.permission_type,
            "effective_immediately": True
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"ê¶Œí•œ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
        raise HTTPException(500, f"ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {str(e)}")
```

### 13.3 ì»¨í…Œì´ë„ˆë³„ ì‚¬ìš©ì ì§€ì› API

```python
@router.get("/containers/{container_id}/analytics")
async def get_container_analytics(
    container_id: int,
    current_user: User = Depends(get_current_user),
    period: str = "month"
):
    """ì»¨í…Œì´ë„ˆ ì‚¬ìš© ë¶„ì„ (ê¶Œí•œ ê¸°ë°˜)"""
    try:
        # 1. ë¶„ì„ ì¡°íšŒ ê¶Œí•œ í™•ì¸
        has_view_permission = await permission_service.check_container_permission(
            current_user.emp_no, container_id, "VIEWER"
        )
        if not has_view_permission:
            raise HTTPException(403, "í•´ë‹¹ ì»¨í…Œì´ë„ˆ ë¶„ì„ ì¡°íšŒ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤")
        
        # 2. ê´€ë¦¬ì ë ˆë²¨ ë¶„ì„ê³¼ ì¼ë°˜ ì‚¬ìš©ì ë¶„ì„ êµ¬ë¶„
        is_admin = await permission_service.check_container_permission(
            current_user.emp_no, container_id, "ADMIN"
        )
        
        # 3. ê¶Œí•œì— ë”°ë¥¸ ë¶„ì„ ë°ì´í„° ì¡°íšŒ
        analytics = await analytics_service.get_container_analytics(
            container_id=container_id,
            period=period,
            user_level="admin" if is_admin else "user",
            requesting_user=current_user.emp_no
        )
        
        return analytics
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"ë¶„ì„ ì¡°íšŒ ì‹¤íŒ¨: {e}")
        raise HTTPException(500, f"ë¶„ì„ ì¡°íšŒ ì‹¤íŒ¨: {str(e)}")
```

### 13.4 ê¶Œí•œ ê¸°ë°˜ ì»¨í…Œì´ë„ˆ API ì—”ë“œí¬ì¸íŠ¸ ì •ë¦¬

```python
# Container Management APIs (ê¶Œí•œ ê¸°ë°˜)
/api/containers/
â”œâ”€â”€ hierarchy                    # GET: ì‚¬ìš©ì ì ‘ê·¼ ê°€ëŠ¥í•œ ê³„ì¸µ êµ¬ì¡°
â”œâ”€â”€ create                      # POST: ì»¨í…Œì´ë„ˆ ìƒì„± (ADMIN/MANAGERë§Œ)
â”œâ”€â”€ {id}/
â”‚   â”œâ”€â”€ info                   # GET: ì»¨í…Œì´ë„ˆ ì •ë³´ (ì ‘ê·¼ ê¶Œí•œ í™•ì¸)
â”‚   â”œâ”€â”€ permissions            # GET: ê¶Œí•œ ëª©ë¡ (ADMINë§Œ)
â”‚   â”œâ”€â”€ permissions/request    # POST: ê¶Œí•œ ìš”ì²­
â”‚   â”œâ”€â”€ permissions/{user_id}  # PUT/DELETE: ê¶Œí•œ ê´€ë¦¬ (ADMINë§Œ)
â”‚   â”œâ”€â”€ analytics             # GET: ì‚¬ìš© ë¶„ì„ (ê¶Œí•œ ë ˆë²¨ë³„ ì œí•œ)
â”‚   â””â”€â”€ documents             # GET: ë¬¸ì„œ ëª©ë¡ (ì ‘ê·¼ ê¶Œí•œ ê¸°ë°˜ í•„í„°ë§)
â”œâ”€â”€ permissions/
â”‚   â”œâ”€â”€ my-containers         # GET: ë‚´ê°€ ì ‘ê·¼ ê°€ëŠ¥í•œ ì»¨í…Œì´ë„ˆ ëª©ë¡
â”‚   â”œâ”€â”€ requests             # GET: ë‚´ ê¶Œí•œ ìš”ì²­ í˜„í™©
â”‚   â””â”€â”€ audit                # GET: ê¶Œí•œ ê°ì‚¬ ë¡œê·¸ (ADMINë§Œ)
â””â”€â”€ admin/
    â”œâ”€â”€ bulk-permission-update  # POST: ëŒ€ëŸ‰ ê¶Œí•œ ì—…ë°ì´íŠ¸
    â”œâ”€â”€ permission-templates    # GET/POST: ê¶Œí•œ í…œí”Œë¦¿ ê´€ë¦¬
    â””â”€â”€ system-audit           # GET: ì‹œìŠ¤í…œ ì „ì²´ ê°ì‚¬ (ì‹œìŠ¤í…œ ê´€ë¦¬ìë§Œ)
```